'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var factory = require('mxgraph');
var debounce = require('lodash.debounce');
var throttle = require('lodash.throttle');
var fastXmlParser = require('fast-xml-parser');
var entities = require('entities');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var factory__default = /*#__PURE__*/_interopDefaultLegacy(factory);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var throttle__default = /*#__PURE__*/_interopDefaultLegacy(throttle);

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @category Navigation
 */
exports.FitType = void 0;
(function (FitType) {
    /** No fit, use dimensions and coordinates from the BPMN diagram. */
    FitType["None"] = "None";
    /** Fit the whole html container available to render the BPMN diagram. */
    FitType["HorizontalVertical"] = "HorizontalVertical";
    /** Fit only horizontally. */
    FitType["Horizontal"] = "Horizontal";
    /** Fit only vertically. */
    FitType["Vertical"] = "Vertical";
    /** Fit and center the BPMN Diagram. */
    FitType["Center"] = "Center";
})(exports.FitType || (exports.FitType = {}));
/**
 * @category Navigation
 * @since 0.24.0
 */
exports.ZoomType = void 0;
(function (ZoomType) {
    ZoomType["In"] = "in";
    ZoomType["Out"] = "out";
})(exports.ZoomType || (exports.ZoomType = {}));

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The real name of the field in the BPMN XSD.
 * @category BPMN
 */
exports.ShapeBpmnElementKind = void 0;
(function (ShapeBpmnElementKind) {
    ShapeBpmnElementKind["LANE"] = "lane";
    ShapeBpmnElementKind["POOL"] = "pool";
    ShapeBpmnElementKind["CALL_ACTIVITY"] = "callActivity";
    ShapeBpmnElementKind["SUB_PROCESS"] = "subProcess";
    // When adding support, uncomment related content in tests
    // test/unit/component/mxgraph/renderer/StyleComputer.test.ts
    // test/unit/component/parser/json/BpmnJsonParser.marker.test.ts (adhoc requires special checks as an additional marker should be present)
    // Generalize test/unit/component/parser/json/BpmnJsonParser.sub.process.test.ts
    // See also, ShapeBpmnSubProcessKind
    // SUB_PROCESS_AD_HOC = 'adHocSubProcess',
    // SUB_PROCESS_TRANSACTION = 'transaction',
    ShapeBpmnElementKind["TASK"] = "task";
    ShapeBpmnElementKind["TASK_USER"] = "userTask";
    ShapeBpmnElementKind["TASK_SERVICE"] = "serviceTask";
    ShapeBpmnElementKind["TASK_RECEIVE"] = "receiveTask";
    ShapeBpmnElementKind["TASK_SEND"] = "sendTask";
    ShapeBpmnElementKind["TASK_MANUAL"] = "manualTask";
    ShapeBpmnElementKind["TASK_SCRIPT"] = "scriptTask";
    ShapeBpmnElementKind["TASK_BUSINESS_RULE"] = "businessRuleTask";
    ShapeBpmnElementKind["GLOBAL_TASK"] = "globalTask";
    ShapeBpmnElementKind["GLOBAL_TASK_USER"] = "globalUserTask";
    ShapeBpmnElementKind["GLOBAL_TASK_MANUAL"] = "globalManualTask";
    ShapeBpmnElementKind["GLOBAL_TASK_SCRIPT"] = "globalScriptTask";
    ShapeBpmnElementKind["GLOBAL_TASK_BUSINESS_RULE"] = "globalBusinessRuleTask";
    ShapeBpmnElementKind["GROUP"] = "group";
    ShapeBpmnElementKind["TEXT_ANNOTATION"] = "textAnnotation";
    ShapeBpmnElementKind["GATEWAY_PARALLEL"] = "parallelGateway";
    ShapeBpmnElementKind["GATEWAY_EXCLUSIVE"] = "exclusiveGateway";
    ShapeBpmnElementKind["GATEWAY_INCLUSIVE"] = "inclusiveGateway";
    ShapeBpmnElementKind["GATEWAY_EVENT_BASED"] = "eventBasedGateway";
    ShapeBpmnElementKind["GATEWAY_COMPLEX"] = "complexGateway";
    ShapeBpmnElementKind["EVENT_START"] = "startEvent";
    ShapeBpmnElementKind["EVENT_END"] = "endEvent";
    ShapeBpmnElementKind["EVENT_INTERMEDIATE_CATCH"] = "intermediateCatchEvent";
    ShapeBpmnElementKind["EVENT_INTERMEDIATE_THROW"] = "intermediateThrowEvent";
    ShapeBpmnElementKind["EVENT_BOUNDARY"] = "boundaryEvent";
})(exports.ShapeBpmnElementKind || (exports.ShapeBpmnElementKind = {}));
/**
 * @category BPMN
 */
exports.ShapeBpmnCallActivityKind = void 0;
(function (ShapeBpmnCallActivityKind) {
    ShapeBpmnCallActivityKind["CALLING_PROCESS"] = "process";
    ShapeBpmnCallActivityKind["CALLING_GLOBAL_TASK"] = "global task";
})(exports.ShapeBpmnCallActivityKind || (exports.ShapeBpmnCallActivityKind = {}));
/**
 * Values available for the `eventGatewayType` property in the BPMN specification.
 * @category BPMN
 */
exports.ShapeBpmnEventBasedGatewayKind = void 0;
(function (ShapeBpmnEventBasedGatewayKind) {
    ShapeBpmnEventBasedGatewayKind["Exclusive"] = "Exclusive";
    /** When no type is provided in the BPMN source. */
    ShapeBpmnEventBasedGatewayKind["None"] = "None";
    ShapeBpmnEventBasedGatewayKind["Parallel"] = "Parallel";
})(exports.ShapeBpmnEventBasedGatewayKind || (exports.ShapeBpmnEventBasedGatewayKind = {}));
/**
 * Base name of the EventDefinition fields in the BPMN XSD for event kinds. In the xsd, the value is <enum_value>EventDefinition.
 *
 * For instance, TERMINATE --> terminateEventDefinition
 * @category BPMN
 */
exports.ShapeBpmnEventDefinitionKind = void 0;
(function (ShapeBpmnEventDefinitionKind) {
    ShapeBpmnEventDefinitionKind["NONE"] = "none";
    ShapeBpmnEventDefinitionKind["TERMINATE"] = "terminate";
    ShapeBpmnEventDefinitionKind["CANCEL"] = "cancel";
    ShapeBpmnEventDefinitionKind["COMPENSATION"] = "compensate";
    ShapeBpmnEventDefinitionKind["CONDITIONAL"] = "conditional";
    ShapeBpmnEventDefinitionKind["ERROR"] = "error";
    ShapeBpmnEventDefinitionKind["ESCALATION"] = "escalation";
    ShapeBpmnEventDefinitionKind["LINK"] = "link";
    ShapeBpmnEventDefinitionKind["MESSAGE"] = "message";
    ShapeBpmnEventDefinitionKind["SIGNAL"] = "signal";
    ShapeBpmnEventDefinitionKind["TIMER"] = "timer";
})(exports.ShapeBpmnEventDefinitionKind || (exports.ShapeBpmnEventDefinitionKind = {}));
/**
 * @category BPMN
 */
exports.ShapeBpmnMarkerKind = void 0;
(function (ShapeBpmnMarkerKind) {
    ShapeBpmnMarkerKind["ADHOC"] = "adhoc";
    ShapeBpmnMarkerKind["COMPENSATION"] = "compensation";
    ShapeBpmnMarkerKind["EXPAND"] = "expand";
    ShapeBpmnMarkerKind["LOOP"] = "loop";
    ShapeBpmnMarkerKind["MULTI_INSTANCE_PARALLEL"] = "parallel multi instance";
    ShapeBpmnMarkerKind["MULTI_INSTANCE_SEQUENTIAL"] = "sequential multi instance";
})(exports.ShapeBpmnMarkerKind || (exports.ShapeBpmnMarkerKind = {}));
/**
 * Base name of the BPMN specification for sub-process kinds.
 * @category BPMN
 */
exports.ShapeBpmnSubProcessKind = void 0;
(function (ShapeBpmnSubProcessKind) {
    ShapeBpmnSubProcessKind["EMBEDDED"] = "embedded";
    ShapeBpmnSubProcessKind["EVENT"] = "event";
    // The following may be only needed for rendering, as we have special types for adHoc and transaction subprocess in ShapeBpmnElementKind
    // TRANSACTION = 'transaction',
    // AD_HOC = 'ad_hoc',
})(exports.ShapeBpmnSubProcessKind || (exports.ShapeBpmnSubProcessKind = {}));

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function convertEmptyStringAndObject(element, acceptEmptyString) {
    if (element === '') {
        return acceptEmptyString ? {} : undefined;
    }
    return element;
}
/**
 * @internal
 */
function ensureIsArray(elements, acceptEmptyString = false) {
    if (elements === undefined || elements === null) {
        return [];
    }
    return ((!Array.isArray(elements) ? [elements] : elements)
        // convert empty elements
        .map(element => convertEmptyStringAndObject(element, acceptEmptyString))
        // remove empty elements
        .filter(Boolean));
}
/**
 * @internal
 */
function filter(arrayToFilter, suffix, options) {
    let pattern = '';
    if (options === null || options === void 0 ? void 0 : options.startingWith) {
        pattern = pattern.concat(`^(${options.startingWith}).*`);
    }
    else if (options === null || options === void 0 ? void 0 : options.notStartingWith) {
        pattern = pattern.concat(`^(?!(${options.notStartingWith})).*`);
    }
    pattern = pattern.concat(`${suffix}$`);
    return arrayToFilter.filter(element => ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? new RegExp(pattern, 'i').test(element) : new RegExp(pattern).test(element)));
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Utils to simplify the management of {@link ShapeBpmnElementKind}.
 *
 * This class is mainly used for internal purpose. You may use it to customize the BPMN theme as proposed in the examples but be aware it is subject to change.
 *
 * @category BPMN
 * @experimental
 */
class ShapeUtil {
    static isEvent(kind) {
        return isKindOf(EVENT_KINDS, kind);
    }
    static eventKinds() {
        return [...EVENT_KINDS];
    }
    static isBoundaryEvent(kind) {
        return exports.ShapeBpmnElementKind.EVENT_BOUNDARY === kind;
    }
    static isStartEvent(kind) {
        return exports.ShapeBpmnElementKind.EVENT_START === kind;
    }
    static isCallActivity(kind) {
        return exports.ShapeBpmnElementKind.CALL_ACTIVITY === kind;
    }
    static isSubProcess(kind) {
        return exports.ShapeBpmnElementKind.SUB_PROCESS === kind;
    }
    static canHaveNoneEvent(kind) {
        return exports.ShapeBpmnElementKind.EVENT_INTERMEDIATE_THROW === kind || exports.ShapeBpmnElementKind.EVENT_END === kind || exports.ShapeBpmnElementKind.EVENT_START === kind;
    }
    static isActivity(kind) {
        return isKindOf(ACTIVITY_KINDS, kind);
    }
    static activityKinds() {
        return [...ACTIVITY_KINDS];
    }
    static isWithDefaultSequenceFlow(kind) {
        return FLOW_NODE_WITH_DEFAULT_SEQUENCE_FLOW_KINDS.includes(kind);
    }
    /**
     * Returns `true` if `kind` is related to a task, for instance {@link ShapeBpmnElementKind.TASK}, {@link ShapeBpmnElementKind.TASK_SERVICE}, but not a {@link ShapeBpmnElementKind.GLOBAL_TASK}.
     */
    static isTask(kind) {
        return isKindOf(TASK_KINDS, kind);
    }
    /**
     * Returns all kinds related to a task, for instance {@link ShapeBpmnElementKind.TASK}, {@link ShapeBpmnElementKind.TASK_SEND}, but not a {@link ShapeBpmnElementKind.GLOBAL_TASK}.
     */
    static taskKinds() {
        return [...TASK_KINDS];
    }
    static gatewayKinds() {
        return [...GATEWAY_KINDS];
    }
    static isGateway(kind) {
        return isKindOf(GATEWAY_KINDS, kind);
    }
    static flowNodeKinds() {
        return Object.values(exports.ShapeBpmnElementKind).filter(kind => !ShapeUtil.isPoolOrLane(kind));
    }
    static isPoolOrLane(kind) {
        return kind == exports.ShapeBpmnElementKind.POOL || kind == exports.ShapeBpmnElementKind.LANE;
    }
}
function filterKind(suffix, options) {
    return filter(Object.values(exports.ShapeBpmnElementKind), suffix, options);
}
function isKindOf(referenceKinds, kind) {
    return Object.values(referenceKinds)
        .map(value => value)
        .includes(kind);
}
const EVENT_KINDS = filterKind('Event');
const GATEWAY_KINDS = filterKind('Gateway');
const TASK_KINDS = filterKind('Task', { ignoreCase: true, notStartingWith: 'global' });
const ACTIVITY_KINDS = [...TASK_KINDS, exports.ShapeBpmnElementKind.CALL_ACTIVITY, exports.ShapeBpmnElementKind.SUB_PROCESS];
const FLOW_NODE_WITH_DEFAULT_SEQUENCE_FLOW_KINDS = [
    ...ACTIVITY_KINDS,
    exports.ShapeBpmnElementKind.GATEWAY_EXCLUSIVE,
    exports.ShapeBpmnElementKind.GATEWAY_INCLUSIVE,
    exports.ShapeBpmnElementKind.GATEWAY_COMPLEX,
];
/**
 * Elements that are effectively used in BPMN diagram as base for eventDefinition i.e all {@link ShapeBpmnEventDefinitionKind} elements except {@link ShapeBpmnEventDefinitionKind.NONE}
 * @internal
 */
const eventDefinitionKinds = Object.values(exports.ShapeBpmnEventDefinitionKind).filter(kind => kind != exports.ShapeBpmnEventDefinitionKind.NONE);

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Enum values are using the real name of the field in the BPMN XSD.
 * @category BPMN
 */
exports.AssociationDirectionKind = void 0;
(function (AssociationDirectionKind) {
    AssociationDirectionKind["NONE"] = "None";
    AssociationDirectionKind["ONE"] = "One";
    AssociationDirectionKind["BOTH"] = "Both";
})(exports.AssociationDirectionKind || (exports.AssociationDirectionKind = {}));
/**
 * Enum values are using the real name of the field in the BPMN XSD.
 * @category BPMN
 */
exports.FlowKind = void 0;
(function (FlowKind) {
    FlowKind["SEQUENCE_FLOW"] = "sequenceFlow";
    FlowKind["MESSAGE_FLOW"] = "messageFlow";
    FlowKind["ASSOCIATION_FLOW"] = "association";
})(exports.FlowKind || (exports.FlowKind = {}));
/**
 * Enum values are using the real name of the `visible message` field in the BPMN XSD, except for `none` that is not present in the specification.
 * @category BPMN
 */
exports.MessageVisibleKind = void 0;
(function (MessageVisibleKind) {
    MessageVisibleKind["NONE"] = "none";
    MessageVisibleKind["INITIATING"] = "initiating";
    MessageVisibleKind["NON_INITIATING"] = "non_initiating";
})(exports.MessageVisibleKind || (exports.MessageVisibleKind = {}));
/**
 * Enum values are used internally to identify sequence the flow markers and to manage their related style.
 * @category BPMN
 */
exports.SequenceFlowKind = void 0;
(function (SequenceFlowKind) {
    SequenceFlowKind["NORMAL"] = "normal";
    SequenceFlowKind["DEFAULT"] = "default";
    SequenceFlowKind["CONDITIONAL_FROM_ACTIVITY"] = "conditional_from_activity";
    SequenceFlowKind["CONDITIONAL_FROM_GATEWAY"] = "conditional_from_gateway";
})(exports.SequenceFlowKind || (exports.SequenceFlowKind = {}));

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mxgraph = initialize();
function initialize() {
    // set options globally, as it is not working when passing options to the factory (https://github.com/jgraph/mxgraph/issues/479)
    // Required otherwise 'Uncaught ReferenceError: assignment to undeclared variable mx...'
    window.mxForceIncludes = false;
    window.mxLoadResources = false;
    // Required otherwise we got 'Uncaught ReferenceError: assignment to undeclared variable mx...'
    window.mxLoadStylesheets = false;
    window.mxResourceExtension = '.txt';
    return factory__default["default"]({});
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Define BPMN specific keys used in mxGraph styles. Use constants defined in this class instead of hard coded string values.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class BpmnStyleIdentifier {
}
// edge
Object.defineProperty(BpmnStyleIdentifier, "EDGE", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.edge'
});
Object.defineProperty(BpmnStyleIdentifier, "EDGE_START_FILL_COLOR", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.edge.startFillColor'
});
Object.defineProperty(BpmnStyleIdentifier, "EDGE_END_FILL_COLOR", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.edge.endFillColor'
});
// kind
Object.defineProperty(BpmnStyleIdentifier, "EVENT_BASED_GATEWAY_KIND", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.gatewayKind'
});
Object.defineProperty(BpmnStyleIdentifier, "EVENT_DEFINITION_KIND", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.eventDefinitionKind'
});
Object.defineProperty(BpmnStyleIdentifier, "GLOBAL_TASK_KIND", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.globalTaskKind'
});
Object.defineProperty(BpmnStyleIdentifier, "SUB_PROCESS_KIND", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.subProcessKind'
});
// state
Object.defineProperty(BpmnStyleIdentifier, "IS_INITIATING", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.isInitiating'
});
Object.defineProperty(BpmnStyleIdentifier, "IS_INSTANTIATING", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.isInstantiating'
});
Object.defineProperty(BpmnStyleIdentifier, "IS_INTERRUPTING", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.isInterrupting'
});
// other identifiers
Object.defineProperty(BpmnStyleIdentifier, "EXTRA_CSS_CLASSES", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.extra.css.classes'
});
Object.defineProperty(BpmnStyleIdentifier, "MARKERS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.markers'
});
Object.defineProperty(BpmnStyleIdentifier, "MESSAGE_FLOW_ICON", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.messageFlowIcon'
});
/**
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class MarkerIdentifier {
}
Object.defineProperty(MarkerIdentifier, "ARROW_DASH", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'bpmn.dash'
});

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Store all rendering defaults used by `bpmn-visualization`.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
exports.StyleDefault = void 0;
(function (StyleDefault) {
    StyleDefault[StyleDefault["STROKE_WIDTH_THIN"] = 2] = "STROKE_WIDTH_THIN";
    StyleDefault[StyleDefault["STROKE_WIDTH_THICK"] = 5] = "STROKE_WIDTH_THICK";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_BOTTOM_MARGIN"] = 7] = "SHAPE_ACTIVITY_BOTTOM_MARGIN";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_TOP_MARGIN"] = 7] = "SHAPE_ACTIVITY_TOP_MARGIN";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_LEFT_MARGIN"] = 7] = "SHAPE_ACTIVITY_LEFT_MARGIN";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_FROM_CENTER_MARGIN"] = 7] = "SHAPE_ACTIVITY_FROM_CENTER_MARGIN";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_MARKER_ICON_MARGIN"] = 5] = "SHAPE_ACTIVITY_MARKER_ICON_MARGIN";
    StyleDefault[StyleDefault["SHAPE_ACTIVITY_MARKER_ICON_SIZE"] = 20] = "SHAPE_ACTIVITY_MARKER_ICON_SIZE";
    StyleDefault[StyleDefault["POOL_LABEL_SIZE"] = 30] = "POOL_LABEL_SIZE";
    StyleDefault["POOL_LABEL_FILL_COLOR"] = "none";
    StyleDefault[StyleDefault["LANE_LABEL_SIZE"] = 30] = "LANE_LABEL_SIZE";
    StyleDefault["LANE_LABEL_FILL_COLOR"] = "none";
    StyleDefault[StyleDefault["TEXT_ANNOTATION_BORDER_LENGTH"] = 10] = "TEXT_ANNOTATION_BORDER_LENGTH";
    StyleDefault["TEXT_ANNOTATION_FILL_COLOR"] = "none";
    StyleDefault["GROUP_FILL_COLOR"] = "none";
    // General
    StyleDefault["DEFAULT_FILL_COLOR"] = "White";
    StyleDefault["DEFAULT_STROKE_COLOR"] = "Black";
    StyleDefault["DEFAULT_FONT_FAMILY"] = "Arial, Helvetica, sans-serif";
    StyleDefault[StyleDefault["DEFAULT_FONT_SIZE"] = 11] = "DEFAULT_FONT_SIZE";
    StyleDefault["DEFAULT_FONT_COLOR"] = "Black";
    StyleDefault[StyleDefault["DEFAULT_MARGIN"] = 0] = "DEFAULT_MARGIN";
    // Shape defaults
    StyleDefault[StyleDefault["SHAPE_ARC_SIZE"] = 20] = "SHAPE_ARC_SIZE";
    // Overlay defaults
    StyleDefault["DEFAULT_OVERLAY_FILL_COLOR"] = "White";
    StyleDefault[StyleDefault["DEFAULT_OVERLAY_FILL_OPACITY"] = 100] = "DEFAULT_OVERLAY_FILL_OPACITY";
    StyleDefault["DEFAULT_OVERLAY_STROKE_COLOR"] = "Black";
    StyleDefault[StyleDefault["DEFAULT_OVERLAY_STROKE_WIDTH"] = 1] = "DEFAULT_OVERLAY_STROKE_WIDTH";
    StyleDefault[StyleDefault["DEFAULT_OVERLAY_FONT_SIZE"] = 11] = "DEFAULT_OVERLAY_FONT_SIZE";
    StyleDefault["DEFAULT_OVERLAY_FONT_COLOR"] = "Black";
    // Edge
    StyleDefault["SEQUENCE_FLOW_CONDITIONAL_FROM_ACTIVITY_MARKER_FILL_COLOR"] = "White";
    StyleDefault["MESSAGE_FLOW_MARKER_START_FILL_COLOR"] = "White";
    StyleDefault["MESSAGE_FLOW_MARKER_END_FILL_COLOR"] = "White";
})(exports.StyleDefault || (exports.StyleDefault = {}));
/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types */
/**
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class StyleUtils {
    static getFillColor(style) {
        return mxgraph.mxUtils.getValue(style, mxgraph.mxConstants.STYLE_FILLCOLOR, exports.StyleDefault.DEFAULT_FILL_COLOR);
    }
    static getStrokeColor(style) {
        return mxgraph.mxUtils.getValue(style, mxgraph.mxConstants.STYLE_STROKECOLOR, exports.StyleDefault.DEFAULT_STROKE_COLOR);
    }
    static getStrokeWidth(style) {
        return mxgraph.mxUtils.getValue(style, mxgraph.mxConstants.STYLE_STROKEWIDTH, exports.StyleDefault.STROKE_WIDTH_THIN);
    }
    static getMargin(style) {
        return mxgraph.mxUtils.getValue(style, mxgraph.mxConstants.STYLE_MARGIN, exports.StyleDefault.DEFAULT_MARGIN);
    }
    static getBpmnEventDefinitionKind(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.EVENT_DEFINITION_KIND, exports.ShapeBpmnEventDefinitionKind.NONE);
    }
    static getBpmnSubProcessKind(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.SUB_PROCESS_KIND, undefined);
    }
    static getBpmnIsInterrupting(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.IS_INTERRUPTING, undefined);
    }
    static getBpmnMarkers(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.MARKERS, undefined);
    }
    static getBpmnIsInstantiating(style) {
        return JSON.parse(mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.IS_INSTANTIATING, false));
    }
    static getBpmnIsInitiating(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.IS_INITIATING, undefined);
    }
    static getBpmnIsParallelEventBasedGateway(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.EVENT_BASED_GATEWAY_KIND, exports.ShapeBpmnEventBasedGatewayKind.Exclusive) == exports.ShapeBpmnEventBasedGatewayKind.Parallel;
    }
    static getBpmnGlobalTaskKind(style) {
        return mxgraph.mxUtils.getValue(style, BpmnStyleIdentifier.GLOBAL_TASK_KIND, undefined);
    }
}
/* eslint-enable @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types */

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Configure the styles used for BPMN rendering.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class StyleConfigurator {
    constructor(graph) {
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graph
        });
        Object.defineProperty(this, "specificFlowStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MapWithDefault([
                [
                    exports.FlowKind.SEQUENCE_FLOW,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_ENDARROW] = mxgraph.mxConstants.ARROW_BLOCK_THIN;
                    },
                ],
                [
                    exports.FlowKind.MESSAGE_FLOW,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_DASHED] = true;
                        style[mxgraph.mxConstants.STYLE_DASH_PATTERN] = '8 5';
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = mxgraph.mxConstants.ARROW_OVAL;
                        style[mxgraph.mxConstants.STYLE_STARTSIZE] = 8;
                        style[mxgraph.mxConstants.STYLE_STARTFILL] = true;
                        style[BpmnStyleIdentifier.EDGE_START_FILL_COLOR] = exports.StyleDefault.MESSAGE_FLOW_MARKER_START_FILL_COLOR;
                        style[mxgraph.mxConstants.STYLE_ENDARROW] = mxgraph.mxConstants.ARROW_BLOCK_THIN;
                        style[mxgraph.mxConstants.STYLE_ENDFILL] = true;
                        style[BpmnStyleIdentifier.EDGE_END_FILL_COLOR] = exports.StyleDefault.MESSAGE_FLOW_MARKER_END_FILL_COLOR;
                    },
                ],
                [
                    exports.FlowKind.ASSOCIATION_FLOW,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_DASHED] = true;
                        style[mxgraph.mxConstants.STYLE_DASH_PATTERN] = '1 2';
                        style[mxgraph.mxConstants.STYLE_ENDARROW] = mxgraph.mxConstants.ARROW_OPEN_THIN;
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = mxgraph.mxConstants.ARROW_OPEN_THIN;
                        style[mxgraph.mxConstants.STYLE_STARTSIZE] = 12;
                    },
                ],
            ])
        });
        Object.defineProperty(this, "specificSequenceFlowStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MapWithDefault([
                [
                    exports.SequenceFlowKind.DEFAULT,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = MarkerIdentifier.ARROW_DASH;
                    },
                ],
                [
                    exports.SequenceFlowKind.CONDITIONAL_FROM_ACTIVITY,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = mxgraph.mxConstants.ARROW_DIAMOND_THIN;
                        style[mxgraph.mxConstants.STYLE_STARTSIZE] = 18;
                        style[mxgraph.mxConstants.STYLE_STARTFILL] = true;
                        style[BpmnStyleIdentifier.EDGE_START_FILL_COLOR] = exports.StyleDefault.SEQUENCE_FLOW_CONDITIONAL_FROM_ACTIVITY_MARKER_FILL_COLOR;
                    },
                ],
            ])
        });
        Object.defineProperty(this, "specificAssociationFlowStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MapWithDefault([
                [
                    exports.AssociationDirectionKind.NONE,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = undefined;
                        style[mxgraph.mxConstants.STYLE_ENDARROW] = undefined;
                    },
                ],
                [
                    exports.AssociationDirectionKind.ONE,
                    (style) => {
                        style[mxgraph.mxConstants.STYLE_STARTARROW] = undefined;
                    },
                ],
                [
                    exports.AssociationDirectionKind.BOTH,
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- prefix parameter name - common practice to acknowledge the fact that some parameter is unused (e.g. in TypeScript compiler)
                    (_style) => {
                        // the style is fully managed by the FlowKind.ASSOCIATION_FLOW style
                    },
                ],
            ])
        });
    }
    configureStyles() {
        this.configureDefaultVertexStyle();
        this.configurePoolStyle();
        this.configureLaneStyle();
        this.configureTextAnnotationStyle();
        this.configureGroupStyle();
        this.configureActivityStyles();
        this.configureEventStyles();
        this.configureGatewayStyles();
        this.configureDefaultEdgeStyle();
        this.configureFlowStyles();
    }
    getStylesheet() {
        return this.graph.getStylesheet();
    }
    putCellStyle(name, style) {
        this.getStylesheet().putCellStyle(name, style);
    }
    configureDefaultVertexStyle() {
        StyleConfigurator.configureCommonDefaultStyle(this.getStylesheet().getDefaultVertexStyle());
    }
    configurePoolStyle() {
        const style = {};
        style[mxgraph.mxConstants.STYLE_SHAPE] = mxgraph.mxConstants.SHAPE_SWIMLANE;
        // label style
        style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_MIDDLE;
        style[mxgraph.mxConstants.STYLE_ALIGN] = mxgraph.mxConstants.ALIGN_CENTER;
        style[mxgraph.mxConstants.STYLE_STARTSIZE] = exports.StyleDefault.POOL_LABEL_SIZE;
        style[mxgraph.mxConstants.STYLE_FILLCOLOR] = exports.StyleDefault.POOL_LABEL_FILL_COLOR;
        this.graph.getStylesheet().putCellStyle(exports.ShapeBpmnElementKind.POOL, style);
    }
    configureLaneStyle() {
        const style = {};
        style[mxgraph.mxConstants.STYLE_SHAPE] = mxgraph.mxConstants.SHAPE_SWIMLANE;
        // label style
        style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_MIDDLE;
        style[mxgraph.mxConstants.STYLE_ALIGN] = mxgraph.mxConstants.ALIGN_CENTER;
        style[mxgraph.mxConstants.STYLE_SWIMLANE_LINE] = 0; // hide the line between the title region and the content area
        style[mxgraph.mxConstants.STYLE_STARTSIZE] = exports.StyleDefault.LANE_LABEL_SIZE;
        style[mxgraph.mxConstants.STYLE_FILLCOLOR] = exports.StyleDefault.LANE_LABEL_FILL_COLOR;
        this.graph.getStylesheet().putCellStyle(exports.ShapeBpmnElementKind.LANE, style);
    }
    configureEventStyles() {
        ShapeUtil.eventKinds().forEach(kind => {
            const style = {};
            style[mxgraph.mxConstants.STYLE_SHAPE] = kind;
            style[mxgraph.mxConstants.STYLE_PERIMETER] = mxgraph.mxPerimeter.EllipsePerimeter;
            style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = kind == exports.ShapeBpmnElementKind.EVENT_END ? exports.StyleDefault.STROKE_WIDTH_THICK : exports.StyleDefault.STROKE_WIDTH_THIN;
            style[mxgraph.mxConstants.STYLE_VERTICAL_LABEL_POSITION] = mxgraph.mxConstants.ALIGN_BOTTOM;
            this.putCellStyle(kind, style);
        });
    }
    configureTextAnnotationStyle() {
        const style = {};
        style[mxgraph.mxConstants.STYLE_SHAPE] = exports.ShapeBpmnElementKind.TEXT_ANNOTATION;
        style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_MIDDLE;
        style[mxgraph.mxConstants.STYLE_ALIGN] = mxgraph.mxConstants.ALIGN_LEFT;
        style[mxgraph.mxConstants.STYLE_SPACING_LEFT] = 5;
        style[mxgraph.mxConstants.STYLE_FILLCOLOR] = exports.StyleDefault.TEXT_ANNOTATION_FILL_COLOR;
        style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = exports.StyleDefault.STROKE_WIDTH_THIN;
        this.putCellStyle(exports.ShapeBpmnElementKind.TEXT_ANNOTATION, style);
    }
    configureGroupStyle() {
        const style = {};
        style[mxgraph.mxConstants.STYLE_ROUNDED] = true;
        style[mxgraph.mxConstants.STYLE_ABSOLUTE_ARCSIZE] = true;
        style[mxgraph.mxConstants.STYLE_ARCSIZE] = exports.StyleDefault.SHAPE_ARC_SIZE;
        style[mxgraph.mxConstants.STYLE_DASHED] = true;
        style[mxgraph.mxConstants.STYLE_DASH_PATTERN] = '7 4 1 4';
        style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = exports.StyleDefault.STROKE_WIDTH_THIN;
        style[mxgraph.mxConstants.STYLE_FILLCOLOR] = exports.StyleDefault.GROUP_FILL_COLOR;
        // Default label positioning
        style[mxgraph.mxConstants.STYLE_ALIGN] = mxgraph.mxConstants.ALIGN_CENTER;
        style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_TOP;
        this.putCellStyle(exports.ShapeBpmnElementKind.GROUP, style);
    }
    configureActivityStyles() {
        ShapeUtil.activityKinds().forEach(kind => {
            const style = {};
            style[mxgraph.mxConstants.STYLE_SHAPE] = kind;
            style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_MIDDLE;
            style[mxgraph.mxConstants.STYLE_ABSOLUTE_ARCSIZE] = true;
            style[mxgraph.mxConstants.STYLE_ARCSIZE] = exports.StyleDefault.SHAPE_ARC_SIZE;
            style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = kind == exports.ShapeBpmnElementKind.CALL_ACTIVITY ? exports.StyleDefault.STROKE_WIDTH_THICK : exports.StyleDefault.STROKE_WIDTH_THIN;
            this.putCellStyle(kind, style);
        });
    }
    configureGatewayStyles() {
        ShapeUtil.gatewayKinds().forEach(kind => {
            const style = {};
            style[mxgraph.mxConstants.STYLE_SHAPE] = kind;
            style[mxgraph.mxConstants.STYLE_PERIMETER] = mxgraph.mxPerimeter.RhombusPerimeter;
            style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = exports.StyleDefault.STROKE_WIDTH_THIN;
            style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_TOP;
            // Default label positioning
            style[mxgraph.mxConstants.STYLE_LABEL_POSITION] = mxgraph.mxConstants.ALIGN_LEFT;
            style[mxgraph.mxConstants.STYLE_VERTICAL_LABEL_POSITION] = mxgraph.mxConstants.ALIGN_TOP;
            this.putCellStyle(kind, style);
        });
    }
    configureDefaultEdgeStyle() {
        const style = this.getStylesheet().getDefaultEdgeStyle();
        style[mxgraph.mxConstants.STYLE_SHAPE] = BpmnStyleIdentifier.EDGE;
        style[mxgraph.mxConstants.STYLE_ENDSIZE] = 12;
        style[mxgraph.mxConstants.STYLE_STROKEWIDTH] = 1.5;
        style[mxgraph.mxConstants.STYLE_ROUNDED] = 1;
        style[mxgraph.mxConstants.STYLE_ARCSIZE] = 5;
        style[mxgraph.mxConstants.STYLE_VERTICAL_ALIGN] = mxgraph.mxConstants.ALIGN_BOTTOM;
        delete style[mxgraph.mxConstants.STYLE_ENDARROW];
        StyleConfigurator.configureCommonDefaultStyle(style);
    }
    static configureCommonDefaultStyle(style) {
        style[mxgraph.mxConstants.STYLE_FONTFAMILY] = exports.StyleDefault.DEFAULT_FONT_FAMILY;
        style[mxgraph.mxConstants.STYLE_FONTSIZE] = exports.StyleDefault.DEFAULT_FONT_SIZE;
        style[mxgraph.mxConstants.STYLE_FONTCOLOR] = exports.StyleDefault.DEFAULT_FONT_COLOR;
        style[mxgraph.mxConstants.STYLE_FILLCOLOR] = exports.StyleDefault.DEFAULT_FILL_COLOR;
        style[mxgraph.mxConstants.STYLE_STROKECOLOR] = exports.StyleDefault.DEFAULT_STROKE_COLOR;
        style[mxgraph.mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = mxgraph.mxConstants.NONE;
        // only works with html labels (enabled by GraphConfigurator)
        style[mxgraph.mxConstants.STYLE_WHITE_SPACE] = 'wrap';
    }
    configureEdgeStyles(styleKinds, specificStyles) {
        styleKinds.forEach(kind => {
            const style = {};
            specificStyles.get(kind)(style);
            this.graph.getStylesheet().putCellStyle(kind.toString(), style);
        });
    }
    configureFlowStyles() {
        this.configureEdgeStyles(Object.values(exports.FlowKind), this.specificFlowStyles);
        this.configureEdgeStyles(Object.values(exports.SequenceFlowKind), this.specificSequenceFlowStyles);
        this.configureEdgeStyles(Object.values(exports.AssociationDirectionKind), this.specificAssociationFlowStyles);
    }
}
class MapWithDefault extends Map {
    get(key) {
        var _a;
        return ((_a = super.get(key)) !== null && _a !== void 0 ? _a : (() => {
            // do nothing intentionally, there is no extra style to configure
        }));
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Compute the icon size proportionally to a ratio of the shape size. The proportions of the icon are left untouched.
 * @internal
 */
function computeScaledIconSize(initialIconSize, iconStyleConfiguration, shapeConfiguration, ratioFromShape) {
    let iconWidthProportionalToShape;
    let iconHeightProportionalToShape;
    if (initialIconSize.height < initialIconSize.width || (initialIconSize.height == initialIconSize.width && shapeConfiguration.width <= shapeConfiguration.height)) {
        iconWidthProportionalToShape = shapeConfiguration.width;
        iconHeightProportionalToShape = (shapeConfiguration.width * initialIconSize.height) / initialIconSize.width;
    }
    else {
        iconWidthProportionalToShape = (shapeConfiguration.height * initialIconSize.width) / initialIconSize.height;
        iconHeightProportionalToShape = shapeConfiguration.height;
    }
    const inset = iconStyleConfiguration.strokeWidth ? (iconStyleConfiguration.strokeWidth - 1) * 2 : 0;
    const paintIconWidth = iconWidthProportionalToShape * ratioFromShape - inset;
    const paintIconHeight = iconHeightProportionalToShape * ratioFromShape - inset;
    return { width: paintIconWidth, height: paintIconHeight };
}
/**
 * Wrapper of `mxAbstractCanvas2D` to simplify method calls when painting icons/markers of BPMN shapes.
 *
 * It can scale dimensions passed to the method of the original `mxAbstractCanvas2D`.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @example
 * The vanilla canvas calls when a scale factor must be applied to position
 * ```javascript
 * const scaleX = 0.26;
 * const scaleY = 0.35;
 * c.moveTo(8 * scaleX, 39 * scaleY);
 * c.lineTo(12 * scaleX, 25 * scaleY);
 * ```
 *
 * @example
 * With `BpmnCanvas`
 * ```javascript
 * const canvas = new BpmnCanvas(c, 0.26, 0.35);
 * canvas.moveTo(8, 39);
 * canvas.lineTo(12, 25);
 * ```
 *
 * @category BPMN Theme
 * @experimental
 */
class BpmnCanvas {
    constructor({ canvas, shapeConfig, iconConfig }) {
        Object.defineProperty(this, "canvas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "iconOriginalSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scaleX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scaleY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "iconPaintingOriginX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "iconPaintingOriginY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "shapeConfiguration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.canvas = canvas;
        this.shapeConfiguration = shapeConfig;
        this.iconOriginalSize = iconConfig.originalSize;
        const ratioFromShape = iconConfig.ratioFromParent;
        if (ratioFromShape) {
            const scaledIconSize = computeScaledIconSize(this.iconOriginalSize, iconConfig.styleConfig, this.shapeConfiguration, ratioFromShape);
            this.scaleX = scaledIconSize.width / this.iconOriginalSize.width;
            this.scaleY = scaledIconSize.height / this.iconOriginalSize.height;
        }
        else {
            this.scaleX = 1;
            this.scaleY = 1;
        }
        this.updateCanvasStyle(iconConfig.styleConfig);
        iconConfig.setIconOriginFunct(this);
    }
    /**
     * Set the icon origin to the top left corner of the shape.
     *
     * @param shapeDimensionProportion proportion of the width/height used to translate the icon origin from the shape origin.
     * @internal
     */
    setIconOriginToShapeTopLeftProportionally(shapeDimensionProportion) {
        const shape = this.shapeConfiguration;
        this.iconPaintingOriginX = shape.x + shape.width / shapeDimensionProportion;
        this.iconPaintingOriginY = shape.y + shape.height / shapeDimensionProportion;
    }
    /**
     * Set the icon origin to the top left corner of the shape.
     */
    setIconOriginToShapeTopLeft(topMargin = exports.StyleDefault.SHAPE_ACTIVITY_TOP_MARGIN, leftMargin = exports.StyleDefault.SHAPE_ACTIVITY_LEFT_MARGIN) {
        const shape = this.shapeConfiguration;
        this.iconPaintingOriginX = shape.x + leftMargin;
        this.iconPaintingOriginY = shape.y + topMargin;
    }
    /**
     * Set the icon origin to ensure that the icon is centered on the shape.
     */
    setIconOriginForIconCentered() {
        const shape = this.shapeConfiguration;
        this.iconPaintingOriginX = shape.x + (shape.width - this.iconOriginalSize.width * this.scaleX) / 2;
        this.iconPaintingOriginY = shape.y + (shape.height - this.iconOriginalSize.height * this.scaleY) / 2;
    }
    /**
     * Set the icon origin to ensure that, on the shape, the icon is horizontally centered and vertically aligned to the bottom.
     */
    setIconOriginForIconBottomCentered(bottomMargin = exports.StyleDefault.SHAPE_ACTIVITY_BOTTOM_MARGIN) {
        const shape = this.shapeConfiguration;
        this.iconPaintingOriginX = shape.x + (shape.width - this.iconOriginalSize.width * this.scaleX) / 2;
        this.iconPaintingOriginY = shape.y + (shape.height - this.iconOriginalSize.height * this.scaleY - bottomMargin);
    }
    /**
     * Set the icon origin to ensure that, on the shape, the icon is vertically aligned to the bottom and translate to the left from the horizontal center.
     */
    setIconOriginForIconOnBottomLeft(bottomMargin = exports.StyleDefault.SHAPE_ACTIVITY_BOTTOM_MARGIN, fromCenterMargin = exports.StyleDefault.SHAPE_ACTIVITY_FROM_CENTER_MARGIN) {
        const shape = this.shapeConfiguration;
        this.iconPaintingOriginX = shape.x + (shape.width - this.iconOriginalSize.width * this.scaleX) / 3 - fromCenterMargin;
        this.iconPaintingOriginY = shape.y + (shape.height - this.iconOriginalSize.height * this.scaleY - bottomMargin);
    }
    /**
     * Translate the icon origin using the scale factor associated to the horizontal and vertical directions.
     *
     * The values should be given with using the icon original size (as translated values will be scaled as other values passed to method of this class).
     *
     * @param dx the horizontal translation
     * @param dy the vertical translation
     */
    translateIconOrigin(dx, dy) {
        this.iconPaintingOriginX += this.scaleX * dx;
        this.iconPaintingOriginY += this.scaleY * dy;
    }
    computeScaleFromOriginX(x) {
        return this.iconPaintingOriginX + x * this.scaleX;
    }
    computeScaleFromOriginY(y) {
        return this.iconPaintingOriginY + y * this.scaleY;
    }
    updateCanvasStyle({ isFilled, strokeColor, fillColor, strokeWidth }) {
        if (isFilled) {
            this.canvas.setFillColor(strokeColor);
        }
        else {
            this.canvas.setFillColor(fillColor);
        }
        this.canvas.setStrokeWidth(strokeWidth);
    }
    arcTo(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
        this.canvas.arcTo(rx * this.scaleX, ry * this.scaleY, angle, largeArcFlag, sweepFlag, this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y));
    }
    begin() {
        this.canvas.begin();
    }
    close() {
        this.canvas.close();
    }
    curveTo(x1, y1, x2, y2, x3, y3) {
        this.canvas.curveTo(this.computeScaleFromOriginX(x1), this.computeScaleFromOriginY(y1), this.computeScaleFromOriginX(x2), this.computeScaleFromOriginY(y2), this.computeScaleFromOriginX(x3), this.computeScaleFromOriginY(y3));
    }
    fill() {
        this.canvas.fill();
    }
    fillAndStroke() {
        this.canvas.fillAndStroke();
    }
    setFillColor(fillColor) {
        this.canvas.setFillColor(fillColor);
    }
    stroke() {
        this.canvas.stroke();
    }
    setStrokeColor(color) {
        this.canvas.setStrokeColor(color);
    }
    setRoundLineJoin() {
        this.canvas.setLineJoin('round');
    }
    lineTo(x, y) {
        this.canvas.lineTo(this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y));
    }
    moveTo(x, y) {
        this.canvas.moveTo(this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y));
    }
    rect(x, y, w, h) {
        this.canvas.rect(this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y), w * this.scaleX, h * this.scaleY);
    }
    roundrect(x, y, w, h, dx, dy) {
        this.canvas.roundrect(this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y), w * this.scaleX, h * this.scaleY, dx, dy);
    }
    ellipse(x, y, w, h) {
        this.canvas.ellipse(this.computeScaleFromOriginX(x), this.computeScaleFromOriginY(y), w * this.scaleX, h * this.scaleY);
    }
    rotateOnIconCenter(theta) {
        const rotationCenterX = this.iconPaintingOriginX + (this.iconOriginalSize.width / 2) * this.scaleX;
        const rotationCenterY = this.iconPaintingOriginY + (this.iconOriginalSize.height / 2) * this.scaleY;
        this.canvas.rotate(theta, false, false, rotationCenterX, rotationCenterY);
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
function buildPaintParameter({ canvas, x, y, width, height, shape, ratioFromParent, isFilled, iconStrokeWidth, }) {
    const shapeStrokeWidth = shape.strokewidth || StyleUtils.getStrokeWidth(shape.style);
    const fillColor = shape.fill || StyleUtils.getFillColor(shape.style);
    const strokeColor = shape.stroke || StyleUtils.getStrokeColor(shape.style);
    const margin = StyleUtils.getMargin(shape.style);
    ratioFromParent !== null && ratioFromParent !== void 0 ? ratioFromParent : (ratioFromParent = 0.25);
    isFilled !== null && isFilled !== void 0 ? isFilled : (isFilled = false);
    iconStrokeWidth !== null && iconStrokeWidth !== void 0 ? iconStrokeWidth : (iconStrokeWidth = 0);
    return {
        canvas,
        ratioFromParent,
        setIconOriginFunct: (internalCanvas) => internalCanvas.setIconOriginForIconCentered(),
        shapeConfig: { x, y, width, height, strokeWidth: shapeStrokeWidth },
        iconStyleConfig: { isFilled, fillColor, strokeColor, strokeWidth: iconStrokeWidth, margin },
    };
}
/**
 * Default implementation for the icons.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class IconPainter {
    paintEmptyIcon() {
        // empty by nature
    }
    /**
     * Utility paint icon methods to easily instantiate a {@link BpmnCanvas} from a {@link PaintParameter}.
     *
     * @param canvas                  mxgraph `mxAbstractCanvas2D` in charge of performing the paint operations.
     * @param ratioFromParent         the actual size of the icon will be computed from the shape dimensions using this ratio.
     * @param setIconOriginFunct      called function to set the origin of the icon. Generally, it calls a method of {@link BpmnCanvas}.
     * @param shapeConfig             dimension and style of the shape where the icon is painted.
     * @param iconStyleConfig         style of the icon.
     * @param originalIconSize        original size of the icon used to compute the scaling/ratio in {@link BpmnCanvas}.
     * @protected
     */
    newBpmnCanvas({ canvas, ratioFromParent, setIconOriginFunct, shapeConfig, iconStyleConfig }, originalIconSize) {
        return new BpmnCanvas({
            canvas,
            shapeConfig,
            iconConfig: {
                originalSize: originalIconSize,
                styleConfig: iconStyleConfig,
                ratioFromParent,
                setIconOriginFunct,
            },
        });
    }
    /**
     * This icon is used by `message event`, `receive task`, `send task`.
     */
    paintEnvelopeIcon(paintParameter) {
        // this implementation is adapted from the draw.io BPMN 'message' symbol
        // https://github.com/jgraph/drawio/blob/0e19be6b42755790a749af30450c78c0d83be765/src/main/webapp/shapes/bpmn/mxBpmnShape2.js#L465
        const originalIconSize = { width: 485.41, height: 321.76 };
        const canvas = this.newBpmnCanvas(paintParameter, originalIconSize);
        const w = originalIconSize.width;
        const h = originalIconSize.height;
        // Paint the envelope outline with dark color
        canvas.rect(0, 0, w, h);
        canvas.fillAndStroke();
        const { iconStyleConfig } = paintParameter;
        if (iconStyleConfig.isFilled) {
            // Choose light color for envelope closure
            canvas.setStrokeColor(iconStyleConfig.fillColor);
        }
        // Paint the envelope closure
        canvas.begin();
        // V line
        canvas.moveTo(0, 0);
        canvas.lineTo(w * 0.5, h * 0.6);
        canvas.lineTo(w, 0);
        // First bottom line
        canvas.moveTo(0, h);
        canvas.lineTo(w / 3, h * 0.45);
        // Second bottom line
        canvas.moveTo(w, h);
        canvas.lineTo((w * 2) / 3, h * 0.45);
        canvas.stroke();
    }
    /**
     * This icon is used by `inclusive gateway` and `terminate event`.
     */
    paintCircleIcon(paintParameter) {
        // highly inspired from mxDoubleEllipse
        const originalIconSize = { width: paintParameter.shapeConfig.width, height: paintParameter.shapeConfig.height };
        const canvas = this.newBpmnCanvas(paintParameter, originalIconSize);
        const w = originalIconSize.width;
        const h = originalIconSize.height;
        if (w > 0 && h > 0) {
            canvas.ellipse(0, 0, w, h);
        }
        if (paintParameter.iconStyleConfig.isFilled) {
            canvas.fillAndStroke();
        }
        else {
            canvas.stroke();
        }
    }
    /**
     * This icon is used by `timer event`.
     */
    paintClockIcon(paintParameter) {
        // implementation adapted from https://www.flaticon.com/free-icon/clock_223404
        const canvas = this.newBpmnCanvas(paintParameter, { height: 152, width: 152 });
        canvas.begin();
        canvas.moveTo(184, 60);
        canvas.curveTo(188.4, 60, 192, 56.4, 192, 52);
        canvas.lineTo(192, 48);
        canvas.curveTo(192, 40, 188.4, 40, 184, 40);
        canvas.curveTo(179.6, 40, 176, 43.6, 176, 48);
        canvas.lineTo(176, 52);
        canvas.curveTo(176, 56.4, 179.6, 60, 184, 60);
        canvas.close();
        canvas.moveTo(184, 308);
        canvas.curveTo(179.6, 308, 176, 311.6, 176, 316);
        canvas.lineTo(176, 320);
        canvas.curveTo(176, 324.4, 179.6, 328, 184, 328);
        canvas.curveTo(188.4, 328, 192, 324.4, 192, 320);
        canvas.lineTo(192, 316);
        canvas.curveTo(192, 311.6, 188.4, 308, 184, 308);
        canvas.close();
        canvas.moveTo(52, 176);
        canvas.lineTo(48, 176);
        canvas.curveTo(43.6, 176, 40, 179.6, 40, 184);
        canvas.curveTo(40, 188.4, 43.6, 192, 48, 192);
        canvas.lineTo(52, 192);
        canvas.curveTo(56.4, 192, 69, 188.4, 60, 184);
        canvas.curveTo(60, 179.6, 56.4, 176, 52, 176);
        canvas.close();
        canvas.moveTo(320, 176);
        canvas.lineTo(316, 176);
        canvas.curveTo(311.6, 176, 308, 179.6, 308, 184);
        canvas.curveTo(308, 188.4, 311.6, 192, 316, 192);
        canvas.lineTo(320, 192);
        canvas.curveTo(324.4, 192, 328, 188.4, 328, 184);
        canvas.curveTo(328, 179.6, 324.4, 176, 320, 176);
        canvas.moveTo(93.6, 82.4);
        canvas.curveTo(90.4, 79.2, 85.6, 79.2, 82.4, 82.4);
        canvas.curveTo(79.2, 85.6, 79.2, 90.4, 82.4, 93.6);
        canvas.lineTo(85.2, 96.4);
        canvas.curveTo(86.8, 98, 88.8, 98.8, 90.8, 98.8);
        canvas.curveTo(92.8, 98.8, 94.4, 98, 96.4, 96.4);
        canvas.curveTo(99.6, 93.2, 99.6, 88.4, 96.4, 85.2);
        canvas.lineTo(93.6, 82.4);
        canvas.moveTo(85.2, 271.6);
        canvas.lineTo(82.4, 274.4);
        canvas.curveTo(79.2, 277.6, 79.2, 282.4, 82.4, 285.6);
        canvas.curveTo(84, 287.2, 86, 288, 88, 288);
        canvas.curveTo(90, 288, 92, 287.2, 93.6, 285.6);
        canvas.lineTo(96.4, 282.8);
        canvas.curveTo(99.6, 279.6, 99.6, 274.8, 96.4, 271.6);
        canvas.curveTo(93.2, 268.4, 88.4, 268.4, 85.2, 271.6);
        canvas.moveTo(274.4, 82.4);
        canvas.lineTo(271.6, 85.2);
        canvas.curveTo(268.4, 88.4, 268.4, 93.2, 271.6, 96.4);
        canvas.curveTo(273.298, 98, 275.2, 98.8, 277.2, 98.8);
        canvas.curveTo(279.2, 98.8, 281.2, 98, 282.8, 96.4);
        canvas.lineTo(285.6, 93.6);
        canvas.curveTo(288.8, 90.4, 288.8, 85.6, 285.6, 82.4);
        canvas.curveTo(282.4, 79.2, 277.6, 79.2, 274.4, 82.4);
        canvas.moveTo(192, 180.8);
        canvas.lineTo(192, 108);
        canvas.curveTo(192, 103.6, 188.4, 100, 184, 100);
        canvas.curveTo(179.6, 100, 176, 103.6, 176, 108);
        canvas.lineTo(176, 184);
        canvas.curveTo(176, 186, 176.8, 188, 178.4, 189.6);
        canvas.lineTo(266, 277.2);
        canvas.curveTo(267.6, 278.8, 269.6, 279.6, 271.6, 279.6);
        canvas.curveTo(273.6, 279.6, 275.6, 278.8, 277.2, 277.2);
        canvas.curveTo(280.4, 274, 280.4, 269.2, 277.2, 266);
        canvas.lineTo(192, 180.8);
        canvas.moveTo(184, 0);
        canvas.curveTo(82.4, 0, 0, 82.4, 0, 184);
        canvas.curveTo(0, 285.6, 82.4, 368, 184, 368);
        canvas.curveTo(285.6, 368, 368, 285.6, 368, 184);
        canvas.curveTo(368, 82.4, 285.6, 0, 184, 0);
        canvas.moveTo(184, 352);
        canvas.curveTo(91.2, 352, 16, 276.8, 16, 184);
        canvas.curveTo(16, 91.2, 91.2, 16, 184, 16);
        canvas.curveTo(276.8, 16, 352, 91.2, 352, 184);
        canvas.curveTo(352, 276.8, 276.8, 352, 184, 352);
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `signal event`.
     */
    paintTriangleIcon(paintParameter) {
        // implementation adapted from https://thenounproject.com/term/triangle/2452089/
        const canvas = this.newBpmnCanvas(paintParameter, { height: 735, width: 849 });
        canvas.begin();
        canvas.moveTo(497, 55);
        canvas.lineTo(817, 609);
        canvas.curveTo(849, 665, 808, 735, 744, 735);
        canvas.lineTo(105, 735);
        canvas.curveTo(40, 735, 0, 665, 32, 609);
        canvas.lineTo(352, 55);
        canvas.curveTo(384, 0, 465, 0, 497, 55);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `escalation event`.
     */
    paintUpArrowheadIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { height: 50, width: 40 });
        canvas.begin();
        canvas.moveTo(0, 49.5);
        canvas.lineTo(19.5, 1);
        canvas.curveTo(19.75, 0.25, 20, 0, 20.25, 0.25);
        canvas.lineTo(40, 49.5);
        canvas.curveTo(40, 49.5, 39.75, 50, 39.6, 49.75);
        canvas.lineTo(20, 30);
        canvas.lineTo(0.4, 49.75);
        canvas.curveTo(0.4, 49.75, 0.25, 50, 0, 49.5);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `compensation event`.
     */
    paintDoubleLeftArrowheadsIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { height: 53.5, width: 105 });
        canvas.begin();
        canvas.moveTo(91.4, 0);
        canvas.curveTo(91.4, 0, 91.2, 0, 91, 0.2);
        canvas.lineTo(50, 25);
        canvas.curveTo(47.9, 25.8, 46.7, 26.6, 46.4, 27.3);
        canvas.lineTo(46.4, 0);
        canvas.curveTo(46.4, 0, 46.2, 0, 46, 0.2);
        canvas.lineTo(4.9, 25);
        canvas.curveTo(2, 26.2, 0, 27.3, 4.9, 28.5);
        canvas.lineTo(45.8, 53);
        canvas.curveTo(46, 53.3, 46.2, 53.5, 46.4, 53.5);
        canvas.lineTo(46.4, 27);
        canvas.curveTo(46.6, 27.3, 47.8, 28.1, 49.9, 29.9);
        canvas.lineTo(90.8, 53.3);
        canvas.curveTo(91, 53.3, 91.2, 53.5, 91.4, 53.5);
        canvas.lineTo(91.4, 0);
        canvas.close();
        canvas.fillAndStroke();
    }
    drawCrossIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { height: 1, width: 1 });
        canvas.begin();
        canvas.moveTo(0.38, 0);
        canvas.lineTo(0.62, 0);
        canvas.lineTo(0.62, 0.38);
        canvas.lineTo(1, 0.38);
        canvas.lineTo(1, 0.62);
        canvas.lineTo(0.62, 0.62);
        canvas.lineTo(0.62, 1);
        canvas.lineTo(0.38, 1);
        canvas.lineTo(0.38, 0.62);
        canvas.lineTo(0, 0.62);
        canvas.lineTo(0, 0.38);
        canvas.lineTo(0.38, 0.38);
        canvas.close();
        return canvas;
    }
    /**
     * This icon is used by `conditional event`.
     */
    paintListIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { height: 60, width: 60 });
        canvas.begin();
        canvas.moveTo(0, 0);
        canvas.lineTo(60, 0);
        canvas.lineTo(60, 60);
        canvas.lineTo(0, 60);
        canvas.lineTo(0, 0);
        canvas.close();
        canvas.moveTo(5, 5);
        canvas.lineTo(55, 5);
        canvas.close();
        canvas.moveTo(5, 21.6);
        canvas.lineTo(55, 21.6);
        canvas.close();
        canvas.moveTo(5, 38.3);
        canvas.lineTo(55, 38.3);
        canvas.close();
        canvas.moveTo(5, 55);
        canvas.lineTo(55, 55);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `exclusive gateway`.
     */
    paintXCrossIcon(paintParameter) {
        const canvas = this.drawCrossIcon(paintParameter);
        canvas.rotateOnIconCenter(45);
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `parallel gateway` and 'event-based gateway'.
     */
    paintPlusCrossIcon(paintParameter) {
        this.drawCrossIcon(paintParameter).fillAndStroke();
    }
    /**
     * This icon is used by `user task`.
     */
    paintPersonIcon(paintParameter) {
        // implementation adapted from https://www.flaticon.com/free-icon/employees_554768
        // use https://github.com/process-analytics/mxgraph-svg2shape to generate the xml stencil and port it to code
        const canvas = this.newBpmnCanvas(Object.assign(Object.assign({}, paintParameter), { iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: true }) }), { height: 239.68, width: 143.61 });
        canvas.begin();
        canvas.moveTo(124.31, 150.29);
        canvas.lineTo(99.66, 141.03);
        canvas.arcTo(6.43, 6.43, 0, 0, 1, 95.51, 135.03);
        canvas.lineTo(95.51, 130.66);
        canvas.arcTo(47.75, 47.75, 0, 0, 0, 119.51, 89.25);
        canvas.lineTo(119.51, 71.25);
        canvas.arcTo(47.62, 47.62, 0, 0, 0, 101.18, 33.64);
        canvas.arcTo(29.35, 29.35, 0, 0, 0, 101.52, 29.14);
        canvas.arcTo(29.68, 29.68, 0, 0, 0, 42.17, 29.14);
        canvas.arcTo(29.24, 29.24, 0, 0, 0, 42.53, 33.63);
        canvas.arcTo(47.65, 47.65, 0, 0, 0, 24.14, 71.23);
        canvas.lineTo(24.14, 89.23);
        canvas.arcTo(47.7, 47.7, 0, 0, 0, 48.19, 130.63);
        canvas.lineTo(48.19, 135.03);
        canvas.arcTo(6.43, 6.43, 0, 0, 1, 44.03, 141.03);
        canvas.lineTo(19.31, 150.29);
        canvas.arcTo(29.81, 29.81, 0, 0, 0, 0.09, 178.03);
        canvas.lineTo(0.09, 233.51);
        canvas.arcTo(5.63, 5.63, 0, 1, 0, 11.34, 233.51);
        canvas.lineTo(11.34, 178.03);
        canvas.arcTo(18.19, 18.19, 0, 0, 1, 11.57, 175.17);
        canvas.lineTo(20.5, 184.11);
        canvas.arcTo(12.32, 12.32, 0, 0, 1, 24.14, 192.89);
        canvas.lineTo(24.14, 233.51);
        canvas.arcTo(5.63, 5.63, 0, 1, 0, 35.39, 233.51);
        canvas.lineTo(35.39, 192.93);
        canvas.arcTo(23.5, 23.5, 0, 0, 0, 28.46, 176.2);
        canvas.lineTo(17.04, 164.78);
        canvas.arcTo(18.34, 18.34, 0, 0, 1, 23.29, 160.78);
        canvas.lineTo(43.65, 153.15);
        canvas.lineTo(66.22, 175.72);
        canvas.lineTo(66.22, 233.51);
        canvas.arcTo(5.63, 5.63, 0, 1, 0, 77.47, 233.51);
        canvas.lineTo(77.47, 175.76);
        canvas.lineTo(100.04, 153.19);
        canvas.lineTo(120.4, 160.82);
        canvas.arcTo(18.39, 18.39, 0, 0, 1, 126.65, 164.82);
        canvas.lineTo(115.24, 176.24);
        canvas.arcTo(23.5, 23.5, 0, 0, 0, 108.31, 192.93);
        canvas.lineTo(108.31, 233.55);
        canvas.arcTo(5.63, 5.63, 0, 1, 0, 119.56, 233.55);
        canvas.lineTo(119.56, 192.93);
        canvas.arcTo(12.35, 12.35, 0, 0, 1, 123.19, 184.15);
        canvas.lineTo(132.13, 175.22);
        canvas.arcTo(18, 18, 0, 0, 1, 132.36, 178.08);
        canvas.lineTo(132.36, 233.56);
        canvas.arcTo(5.63, 5.63, 0, 0, 0, 143.61, 233.56);
        canvas.lineTo(143.61, 178.03);
        canvas.arcTo(29.81, 29.81, 0, 0, 0, 124.31, 150.29);
        canvas.close();
        canvas.moveTo(71.85, 10.72);
        canvas.arcTo(18.46, 18.46, 0, 0, 1, 90.17, 27.18);
        canvas.arcTo(47.68, 47.68, 0, 0, 0, 53.53, 27.18);
        canvas.arcTo(18.44, 18.44, 0, 0, 1, 71.85, 10.72);
        canvas.close();
        canvas.moveTo(35.39, 71.23);
        canvas.arcTo(36.46, 36.46, 0, 0, 1, 108.31, 71.23);
        canvas.lineTo(108.31, 77.4);
        canvas.curveTo(82.12, 75.4, 56.97, 60.55, 56.71, 60.4);
        canvas.arcTo(5.62, 5.62, 0, 0, 0, 48.78, 62.71);
        canvas.curveTo(46.24, 67.79, 40.45, 71.89, 35.39, 74.62);
        canvas.close();
        canvas.moveTo(35.39, 89.23);
        canvas.lineTo(35.39, 87.08);
        canvas.curveTo(40.55, 84.85, 49.73, 80.08, 55.67, 72.66);
        canvas.curveTo(64.83, 77.46, 85.92, 87.21, 108.31, 88.66);
        canvas.lineTo(108.31, 89.24);
        canvas.arcTo(36.46, 36.46, 0, 1, 1, 35.39, 89.24);
        canvas.close();
        canvas.moveTo(71.85, 165.45);
        canvas.lineTo(54.06, 147.69);
        canvas.arcTo(17.7, 17.7, 0, 0, 0, 59.43, 135.32);
        canvas.arcTo(47.57, 47.57, 0, 0, 0, 84.27, 135.32);
        canvas.arcTo(17.7, 17.7, 0, 0, 0, 89.64, 147.69);
        canvas.close();
        canvas.fill();
    }
    /**
     * This icon is used by `service tasks`.
     */
    paintGearIcon(paintParameter) {
        // this implementation is adapted from the draw.io BPMN 'Service Task' stencil
        // https://github.com/jgraph/drawio/blob/9394fb0f1430d2c869865827b2bbef5639f63478/src/main/webapp/stencils/bpmn.xml#L898
        // icon coordinates fill a 100x100 rectangle (approximately: 90x90 + foreground translation)
        const canvas = this.newBpmnCanvas(paintParameter, { height: 100, width: 100 });
        // background
        IconPainter.paintGearIconBackground(canvas);
        // foreground
        canvas.translateIconOrigin(14, 14);
        IconPainter.paintGearIconForeground(canvas);
    }
    static paintGearIconBackground(canvas) {
        canvas.begin();
        canvas.moveTo(2.06, 24.62);
        canvas.lineTo(10.17, 30.95);
        canvas.lineTo(9.29, 37.73);
        canvas.lineTo(0, 41.42);
        canvas.lineTo(2.95, 54.24);
        canvas.lineTo(13.41, 52.92);
        canvas.lineTo(17.39, 58.52);
        canvas.lineTo(13.56, 67.66);
        canvas.lineTo(24.47, 74.44);
        canvas.lineTo(30.81, 66.33);
        canvas.lineTo(37.88, 67.21);
        canvas.lineTo(41.57, 76.5);
        canvas.lineTo(54.24, 73.55);
        canvas.lineTo(53.06, 62.94);
        canvas.lineTo(58.52, 58.52);
        canvas.lineTo(67.21, 63.09);
        canvas.lineTo(74.58, 51.88);
        canvas.lineTo(66.03, 45.25);
        canvas.lineTo(66.92, 38.62);
        canvas.lineTo(76.5, 34.93);
        canvas.lineTo(73.7, 22.26);
        canvas.lineTo(62.64, 23.44);
        canvas.lineTo(58.81, 18.42);
        canvas.lineTo(62.79, 8.7);
        canvas.lineTo(51.74, 2.21);
        canvas.lineTo(44.81, 10.47);
        canvas.lineTo(38.03, 9.43);
        canvas.lineTo(33.75, 0);
        canvas.lineTo(21.52, 3.24);
        canvas.lineTo(22.7, 13.56);
        canvas.lineTo(18.13, 17.54);
        canvas.lineTo(8.7, 13.56);
        canvas.close();
        const arcStartX = 24.8;
        const arcStartY = 39;
        IconPainter.paintGearInnerCircle(canvas, arcStartX, arcStartY);
    }
    static paintGearIconForeground(canvas) {
        canvas.begin();
        canvas.moveTo(16.46, 41.42);
        canvas.lineTo(24.57, 47.75);
        canvas.lineTo(23.69, 54.53);
        canvas.lineTo(14.4, 58.22);
        canvas.lineTo(17.35, 71.04);
        canvas.lineTo(27.81, 69.72);
        canvas.lineTo(31.79, 75.32);
        canvas.lineTo(27.96, 84.46);
        canvas.lineTo(38.87, 91.24);
        canvas.lineTo(45.21, 83.13);
        canvas.lineTo(52.28, 84.01);
        canvas.lineTo(55.97, 93.3);
        canvas.lineTo(68.64, 90.35);
        canvas.lineTo(67.46, 79.74);
        canvas.lineTo(72.92, 75.32);
        canvas.lineTo(81.61, 79.89);
        canvas.lineTo(88.98, 68.68);
        canvas.lineTo(80.43, 62.05);
        canvas.lineTo(81.32, 55.42);
        canvas.lineTo(90.9, 51.73);
        canvas.lineTo(88.1, 39.06);
        canvas.lineTo(77.04, 40.24);
        canvas.lineTo(73.21, 35.22);
        canvas.lineTo(77.19, 25.5);
        canvas.lineTo(66.14, 19.01);
        canvas.lineTo(59.21, 27.27);
        canvas.lineTo(52.43, 26.23);
        canvas.lineTo(48.15, 16.8);
        canvas.lineTo(35.92, 20.04);
        canvas.lineTo(37.1, 30.36);
        canvas.lineTo(32.53, 34.34);
        canvas.lineTo(23.1, 30.36);
        canvas.close();
        const arcStartX = 39.2;
        const arcStartY = 55.8;
        IconPainter.paintGearInnerCircle(canvas, arcStartX, arcStartY);
        // fill the inner circle to mask the background
        canvas.begin();
        IconPainter.paintGearInnerCircle(canvas, arcStartX, arcStartY);
    }
    static paintGearInnerCircle(canvas, arcStartX, arcStartY) {
        const arcRay = 13.5;
        canvas.moveTo(arcStartX, arcStartY);
        canvas.arcTo(arcRay, arcRay, 0, 1, 1, arcStartX + 2 * arcRay, arcStartY);
        canvas.arcTo(arcRay, arcRay, 0, 0, 1, arcStartX, arcStartY);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used to render the `expand marker` on `activities`.
     */
    paintExpandIcon(paintParameter) {
        const originalIconSize = { width: 16, height: 16 };
        const canvas = this.newBpmnCanvas(paintParameter, originalIconSize);
        const w = originalIconSize.width;
        const h = originalIconSize.height;
        // Rounded rectangle
        canvas.roundrect(0, 0, w, h, 2, 2);
        canvas.stroke();
        // Cross
        canvas.begin();
        canvas.moveTo(w / 2, h / 4);
        canvas.lineTo(w / 2, (h * 3) / 4);
        canvas.close();
        canvas.moveTo(w / 4, h / 2);
        canvas.lineTo((w * 3) / 4, h / 2);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used to render the `loop marker` on `activities`.
     */
    paintLoopIcon(paintParameter) {
        // this implementation is adapted from the draw.io BPMN 'Loop'
        // https://github.com/jgraph/drawio/blob/9394fb0f1430d2c869865827b2bbef5639f63478/src/main/webapp/stencils/bpmn.xml#L543
        const { iconStyleConfig } = paintParameter;
        iconStyleConfig.fillColor = iconStyleConfig.strokeColor;
        const canvas = this.newBpmnCanvas(paintParameter, { width: 22.49, height: 21.62 });
        // Loop
        canvas.begin();
        canvas.moveTo(5.5, 19.08);
        canvas.arcTo(8, 8, 0, 1, 1, 10.5, 21.08);
        canvas.stroke();
        // Arrow
        canvas.begin();
        canvas.moveTo(7.5, 14.08);
        canvas.lineTo(5.75, 19.08);
        canvas.lineTo(0, 17.08);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used to render the `sequential multi-instance marker` on `activities`.
     */
    paintSequentialMultiInstanceIcon(paintParameter) {
        const originalIconSize = { width: 16, height: 16 };
        const bpmnCanvas = this.newBpmnCanvas(paintParameter, originalIconSize);
        const { canvas, iconStyleConfig } = paintParameter;
        canvas.setFillColor(iconStyleConfig.strokeColor);
        const barWidth = originalIconSize.width;
        const barHeight = originalIconSize.height / 5; // 3 bars + 2 interspaces
        bpmnCanvas.rect(0, 0, barWidth, barHeight);
        bpmnCanvas.fill();
        bpmnCanvas.rect(0, 2 * barHeight, barWidth, barHeight);
        bpmnCanvas.fill();
        bpmnCanvas.rect(0, 4 * barHeight, barWidth, barHeight);
        bpmnCanvas.fill();
    }
    /**
     * This icon is used to render the `parallel multi-instance marker` on `activities`.
     */
    paintParallelMultiInstanceIcon(paintParameter) {
        const originalIconSize = { width: 16, height: 16 };
        const bpmnCanvas = this.newBpmnCanvas(paintParameter, originalIconSize);
        const { canvas, iconStyleConfig } = paintParameter;
        canvas.setFillColor(iconStyleConfig.strokeColor);
        const barWidth = originalIconSize.width / 5; // 3 bars + 2 interspaces
        const barHeight = originalIconSize.height;
        bpmnCanvas.begin();
        bpmnCanvas.rect(0, 0, barWidth, barHeight);
        bpmnCanvas.fill();
        bpmnCanvas.rect(2 * barWidth, 0, barWidth, barHeight);
        bpmnCanvas.fill();
        bpmnCanvas.rect(4 * barWidth, 0, barWidth, barHeight);
        bpmnCanvas.fill();
    }
    /**
     * This icon is used by `link event`.
     */
    paintRightArrowIcon(paintParameter) {
        // this implementation is adapted from https://www.flaticon.com/free-icon/right-arrow_222330
        const canvas = this.newBpmnCanvas(paintParameter, { width: 512, height: 415.23 });
        canvas.setRoundLineJoin();
        canvas.begin();
        canvas.moveTo(512, 207.61);
        canvas.lineTo(304.38, 0);
        canvas.lineTo(304.38, 135.39);
        canvas.lineTo(0, 135.39);
        canvas.lineTo(0, 279.84);
        canvas.lineTo(304.38, 279.84);
        canvas.lineTo(304.38, 415.23);
        canvas.lineTo(512, 207.61);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `error event`.
     */
    paintErrorIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { width: 72.44, height: 71.82 });
        canvas.begin();
        canvas.moveTo(0, 53.32);
        canvas.lineTo(19.48, 0);
        canvas.lineTo(19.48, 0);
        canvas.lineTo(50.85, 40.07);
        canvas.lineTo(72.44, 18.21);
        canvas.lineTo(53.12, 71.82);
        canvas.lineTo(22.5, 31.37);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `manual task`.
     */
    paintHandIcon(paintParameter) {
        // this implementation is adapted from the noun project 'hand' icon
        // https://thenounproject.com/term/hand/7660/
        const canvas = this.newBpmnCanvas(paintParameter, { width: 343.65, height: 354.12 });
        canvas.begin();
        canvas.moveTo(231.66, 336.39);
        canvas.curveTo(240.84, 316.9, 220.53, 306.92, 220.53, 306.92);
        canvas.curveTo(215.2, 303.67, 188.58, 287.43, 140.67, 258.19);
        canvas.lineTo(146.33, 248.39);
        canvas.curveTo(223.98, 269.38, 267.12, 281.04, 275.75, 283.38);
        canvas.curveTo(275.75, 283.38, 297.25, 288, 301.42, 267.77);
        canvas.curveTo(306.34, 245.29, 288.32, 238.63, 288.32, 238.63);
        canvas.curveTo(279.91, 236.44, 237.86, 225.48, 162.18, 205.75);
        canvas.lineTo(165.2, 194.8);
        canvas.curveTo(255.88, 204.4, 306.27, 209.73, 316.34, 210.8);
        canvas.curveTo(316.34, 210.8, 339.89, 212.16, 341.76, 189.55);
        canvas.curveTo(343.65, 166.93, 320.5, 164.13, 320.5, 164.13);
        canvas.curveTo(310.43, 163.1, 260.04, 157.99, 169.35, 148.77);
        canvas.lineTo(169.35, 138.97);
        canvas.curveTo(253.41, 132.12, 300.11, 128.32, 309.45, 127.56);
        canvas.curveTo(309.45, 127.56, 332.27, 122.38, 332.27, 102.61);
        canvas.curveTo(332.27, 82.85, 305.48, 81.87, 305.48, 81.87);
        canvas.curveTo(293.99, 82.2, 236.54, 83.88, 133.13, 86.9);
        canvas.lineTo(127.61, 81.87);
        canvas.curveTo(145.3, 59.39, 155.12, 46.9, 157.09, 44.41);
        canvas.curveTo(157.09, 44.41, 171.12, 26.8, 156.78, 12.72);
        canvas.curveTo(143.83, 0, 124.08, 14.49, 124.08, 14.49);
        canvas.curveTo(116.45, 19.41, 78.35, 44.06, 9.77, 88.43);
        canvas.lineTo(0, 251.94);
        canvas.curveTo(122.84, 308.79, 191.09, 340.37, 204.74, 346.69);
        canvas.curveTo(204.74, 346.69, 222.91, 354.12, 231.66, 336.39);
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `script task`.
     */
    paintScriptIcon(paintParameter) {
        // this implementation is adapted from the noun project 'script' icon
        // https://thenounproject.com/term/script/2331578/
        paintParameter.iconStyleConfig.fillColor = paintParameter.iconStyleConfig.strokeColor;
        const canvas = this.newBpmnCanvas(paintParameter, { width: 458.75, height: 461.64 });
        // Shape
        canvas.begin();
        canvas.moveTo(67.85, 0.57);
        canvas.curveTo(50.73, 0, 33.26, 8.86, 22.35, 18.84);
        canvas.curveTo(8.11, 32.15, 0, 50.77, 0, 70.26);
        canvas.curveTo(0, 73.15, 0, 87.59, 0, 113.6);
        canvas.curveTo(55.4, 113.6, 86.18, 113.6, 92.33, 113.6);
        canvas.curveTo(94.92, 150.46, 85.64, 180.4, 74.22, 211.27);
        canvas.curveTo(40.16, 298.07, 30.77, 339.83, 55.56, 410.87);
        canvas.curveTo(63.72, 438.26, 87.59, 457.85, 114.91, 461.09);
        canvas.curveTo(216.96, 460.85, 294.9, 461.64, 388.41, 461.2);
        canvas.curveTo(407.2, 461.09, 425.14, 453.55, 438.3, 440.13);
        canvas.curveTo(451.46, 426.71, 458.75, 403.06, 458.46, 384.26);
        canvas.curveTo(458.43, 382.23, 458.18, 365.93, 458.15, 363.89);
        canvas.curveTo(432.12, 364.24, 406.09, 364.04, 380.06, 364.04);
        canvas.curveTo(377.61, 347.52, 377.24, 337.58, 378.28, 324.48);
        canvas.curveTo(380.5, 296.47, 389.08, 273.36, 398.59, 247.1);
        canvas.curveTo(408.11, 220.83, 418.41, 191.47, 420.86, 154.24);
        canvas.curveTo(422.11, 135.34, 421.4, 110.24, 417.77, 86.75);
        canvas.curveTo(417.76, 86.71, 417.73, 86.54, 417.69, 86.22);
        canvas.curveTo(417.64, 85.95, 417.61, 85.79, 417.6, 85.76);
        canvas.curveTo(414.03, 68.13, 410.49, 48.84, 399.79, 31.47);
        canvas.curveTo(389.09, 14.11, 366.95, 0.59, 341.75, 0.59);
        canvas.curveTo(286.97, 0.59, 122.63, 0.57, 67.85, 0.57);
        canvas.close();
        canvas.moveTo(85.04, 72.68);
        canvas.curveTo(80.63, 72.68, 45.33, 72.68, 40.92, 72.68);
        canvas.curveTo(40.46, 58.4, 47.15, 51.87, 50.27, 48.75);
        canvas.curveTo(55.8, 44.28, 59.84, 41, 73.82, 41);
        canvas.curveTo(78.45, 52.13, 82.23, 62.71, 85.04, 72.68);
        canvas.close();
        canvas.moveTo(364.94, 52.9);
        canvas.curveTo(370, 61.11, 373.9, 76.44, 377.38, 93.51);
        canvas.curveTo(380.35, 113.1, 381.01, 136.42, 380.02, 151.57);
        canvas.curveTo(377.97, 182.76, 369.51, 207.12, 360.1, 233.1);
        canvas.curveTo(350.69, 259.09, 340.27, 286.77, 337.53, 321.27);
        canvas.curveTo(336.38, 335.86, 336.72, 346.69, 338.87, 364.01);
        canvas.curveTo(326.35, 364.01, 263.75, 364.01, 151.06, 364.01);
        canvas.curveTo(151.06, 382.2, 151.06, 392.31, 151.06, 394.33);
        canvas.curveTo(147.77, 404.8, 138.9, 418.2, 127.43, 419.94);
        canvas.curveTo(111.49, 422.35, 97.86, 411.8, 94.75, 399.19);
        canvas.curveTo(65.14, 321.99, 94.93, 275.54, 112.57, 225.47);
        canvas.curveTo(130.14, 177.95, 137.92, 117.41, 112.71, 42.09);
        canvas.curveTo(192.88, 41.9, 274.33, 42.21, 342.89, 41.98);
        canvas.curveTo(357.15, 42.03, 359.83, 44.61, 364.94, 52.9);
        canvas.close();
        canvas.moveTo(409.96, 399.48);
        canvas.curveTo(409.96, 408.42, 398.54, 425.67, 392.02, 425.67);
        canvas.curveTo(325.19, 425.79, 252.29, 425.67, 185.23, 425.67);
        canvas.curveTo(189.88, 424.43, 194.66, 405.64, 194.66, 399.48);
        canvas.curveTo(237.72, 399.48, 388.43, 399.48, 409.96, 399.48);
        canvas.close();
        canvas.fill();
        // Lines
        canvas.begin();
        canvas.moveTo(182.1, 131.2);
        canvas.lineTo(182.1, 151.68);
        canvas.lineTo(321.89, 151.68);
        canvas.lineTo(321.89, 131.2);
        canvas.lineTo(182.1, 131.2);
        canvas.close();
        canvas.moveTo(162.25, 251.09);
        canvas.lineTo(162.25, 271.49);
        canvas.lineTo(301.96, 271.49);
        canvas.lineTo(301.96, 251.09);
        canvas.lineTo(162.25, 251.09);
        canvas.close();
        canvas.fill();
    }
    /**
     * This icon is used by `business rule task`.
     */
    paintTableIcon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { width: 640, height: 640 });
        // Shape
        canvas.begin();
        canvas.moveTo(0.19, 0.1);
        canvas.lineTo(298.78, 0.1);
        canvas.lineTo(298.78, 198.88);
        canvas.lineTo(0.19, 198.88);
        canvas.lineTo(0.19, 0.1);
        canvas.close();
        canvas.fillAndStroke();
        canvas.begin();
        canvas.moveTo(0, 0);
        canvas.lineTo(298.78, 0);
        canvas.lineTo(298.78, 48.88);
        canvas.lineTo(0, 48.88);
        canvas.lineTo(0, 0);
        canvas.close();
        canvas.fillAndStroke();
        canvas.begin();
        canvas.moveTo(0, 48.88);
        canvas.lineTo(98.78, 48.88);
        canvas.lineTo(98.78, 198.88);
        canvas.lineTo(0, 198.88);
        canvas.lineTo(0, 48.88);
        canvas.close();
        canvas.fillAndStroke();
        canvas.begin();
        canvas.moveTo(1.09, 122.69);
        canvas.lineTo(298.78, 122.69);
        canvas.close();
        canvas.fillAndStroke();
        canvas.setFillColor(paintParameter.iconStyleConfig.strokeColor);
        canvas.begin();
        canvas.moveTo(0, 0);
        canvas.lineTo(298.78, 0);
        canvas.lineTo(298.78, 48.88);
        canvas.lineTo(0, 48.88);
        canvas.lineTo(0, 0);
        canvas.close();
        canvas.fillAndStroke();
    }
    /**
     * This icon is used by `event-based gateway`.
     */
    paintPentagon(paintParameter) {
        const canvas = this.newBpmnCanvas(paintParameter, { width: 16, height: 16 });
        // Shape
        canvas.begin();
        canvas.moveTo(16, 6.5);
        canvas.lineTo(8, 0);
        canvas.lineTo(0, 6.5);
        canvas.lineTo(3, 16);
        canvas.lineTo(13, 16);
        canvas.lineTo(16, 6.5);
        canvas.lineTo(8, 0); // extra line to ensure the path is fully closed (otherwise, there is a glitch on the latest corner)
        canvas.stroke();
    }
}
/**
 * Hold the instance of {@link IconPainter} used by the BPMN Theme.
 *
 * **WARN**: You may use it to customize the BPMN Theme as suggested in the examples. But be aware that the way the default BPMN theme can be modified is subject to change.
 *
 * @category BPMN Theme
 * @experimental
 */
class IconPainterProvider {
    static get() {
        return this.instance;
    }
    static set(painter) {
        this.instance = painter;
    }
}
Object.defineProperty(IconPainterProvider, "instance", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new IconPainter()
});

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class EventShape extends mxgraph.mxEllipse {
    constructor() {
        super(undefined, undefined, undefined); // the configuration is passed with the styles at runtime
        Object.defineProperty(this, "iconPainter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: IconPainterProvider.get()
        });
        // refactor: when all/more event types will be supported, we could move to a Record/MappedType
        Object.defineProperty(this, "iconPainters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map([
                [exports.ShapeBpmnEventDefinitionKind.MESSAGE, (paintParameter) => this.iconPainter.paintEnvelopeIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.5 }))],
                [exports.ShapeBpmnEventDefinitionKind.TERMINATE, (paintParameter) => this.iconPainter.paintCircleIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.6 }))],
                [
                    exports.ShapeBpmnEventDefinitionKind.TIMER,
                    (paintParameter) => this.iconPainter.paintClockIcon(Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(5) })),
                ],
                [
                    exports.ShapeBpmnEventDefinitionKind.SIGNAL,
                    (paintParameter) => this.iconPainter.paintTriangleIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.55, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: exports.StyleDefault.STROKE_WIDTH_THIN.valueOf() }), setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(4) })),
                ],
                [
                    exports.ShapeBpmnEventDefinitionKind.LINK,
                    (paintParameter) => this.iconPainter.paintRightArrowIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.55, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: 1.5 }) })),
                ],
                [
                    exports.ShapeBpmnEventDefinitionKind.ERROR,
                    (paintParameter) => this.iconPainter.paintErrorIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.55, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: 1.5 }) })),
                ],
                [
                    exports.ShapeBpmnEventDefinitionKind.COMPENSATION,
                    (paintParameter) => this.iconPainter.paintDoubleLeftArrowheadsIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.7, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: 1.5 }) })),
                ],
                [exports.ShapeBpmnEventDefinitionKind.CANCEL, (paintParameter) => this.iconPainter.paintXCrossIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.78 }))],
                [
                    exports.ShapeBpmnEventDefinitionKind.ESCALATION,
                    (paintParameter) => this.iconPainter.paintUpArrowheadIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.55, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: exports.StyleDefault.STROKE_WIDTH_THIN.valueOf() }) })),
                ],
                [
                    exports.ShapeBpmnEventDefinitionKind.CONDITIONAL,
                    (paintParameter) => this.iconPainter.paintListIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.6, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: 1.5 }) })),
                ],
            ])
        });
        Object.defineProperty(this, "withFilledIcon", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    paintVertexShape(c, x, y, w, h) {
        const paintParameter = buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this, isFilled: this.withFilledIcon });
        EventShape.setDashedOuterShapePattern(paintParameter, StyleUtils.getBpmnIsInterrupting(this.style));
        this.paintOuterShape(paintParameter);
        EventShape.restoreOriginalOuterShapePattern(paintParameter);
        this.paintInnerShape(paintParameter);
    }
    paintOuterShape({ canvas, shapeConfig: { x, y, width, height } }) {
        super.paintVertexShape(canvas, x, y, width, height);
    }
    paintInnerShape(paintParameter) {
        const paintIcon = this.iconPainters.get(StyleUtils.getBpmnEventDefinitionKind(this.style)) || (() => this.iconPainter.paintEmptyIcon());
        paintIcon(paintParameter);
    }
    static setDashedOuterShapePattern(paintParameter, isInterrupting) {
        paintParameter.canvas.save(); // ensure we can later restore the configuration
        if (isInterrupting === 'false') {
            paintParameter.canvas.setDashed(true, false);
            paintParameter.canvas.setDashPattern('3 2');
        }
    }
    static restoreOriginalOuterShapePattern(paintParameter) {
        paintParameter.canvas.restore();
    }
}
/**
 * @internal
 */
class EndEventShape extends EventShape {
    constructor() {
        super();
        this.withFilledIcon = true;
    }
}
/**
 * @internal
 */
class IntermediateEventShape extends EventShape {
    // this implementation is adapted from the draw.io BPMN 'throwing' outlines
    // https://github.com/jgraph/drawio/blob/0e19be6b42755790a749af30450c78c0d83be765/src/main/webapp/shapes/bpmn/mxBpmnShape2.js#L431
    paintOuterShape({ canvas, shapeConfig: { x, y, width, height, strokeWidth } }) {
        canvas.ellipse(x, y, width, height);
        canvas.fillAndStroke();
        const inset = strokeWidth * 1.5;
        canvas.ellipse(width * 0.02 + inset + x, height * 0.02 + inset + y, width * 0.96 - 2 * inset, height * 0.96 - 2 * inset);
        canvas.stroke();
    }
}
/**
 * @internal
 */
class ThrowIntermediateEventShape extends IntermediateEventShape {
    constructor() {
        super();
        this.withFilledIcon = true;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GatewayShape extends mxgraph.mxRhombus {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "iconPainter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: IconPainterProvider.get()
        });
    }
    paintVertexShape(c, x, y, w, h) {
        const paintParameter = buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this });
        this.paintOuterShape(paintParameter);
        this.paintInnerShape(paintParameter);
    }
    paintOuterShape({ canvas, shapeConfig: { x, y, width, height } }) {
        super.paintVertexShape(canvas, x, y, width, height);
    }
}
/**
 * @internal
 */
class ExclusiveGatewayShape extends GatewayShape {
    paintInnerShape(paintParameter) {
        this.iconPainter.paintXCrossIcon(Object.assign(Object.assign({}, paintParameter), { iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: true }), ratioFromParent: 0.5 }));
    }
}
/**
 * @internal
 */
class ParallelGatewayShape extends GatewayShape {
    paintInnerShape(paintParameter) {
        this.iconPainter.paintPlusCrossIcon(Object.assign(Object.assign({}, paintParameter), { iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: true }), ratioFromParent: 0.5 }));
    }
}
/**
 * @internal
 */
class InclusiveGatewayShape extends GatewayShape {
    paintInnerShape(paintParameter) {
        this.iconPainter.paintCircleIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.62, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: false, strokeWidth: exports.StyleDefault.STROKE_WIDTH_THICK.valueOf() }) }));
    }
}
/**
 * @internal
 */
class ComplexGatewayShape extends GatewayShape {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    paintInnerShape(paintParameter) {
        this.fill = 'red';
    }
}
/**
 * @internal
 */
class EventBasedGatewayShape extends GatewayShape {
    paintInnerShape(paintParameter) {
        paintParameter = Object.assign(Object.assign({}, paintParameter), { iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { strokeWidth: 1 }) });
        // circle (simple or double)
        this.iconPainter.paintCircleIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.55 }));
        if (!StyleUtils.getBpmnIsInstantiating(this.style)) {
            this.iconPainter.paintCircleIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.45 }));
        }
        // inner icon
        const innerIconPaintParameter = Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.3 });
        if (StyleUtils.getBpmnIsParallelEventBasedGateway(this.style)) {
            this.iconPainter.paintPlusCrossIcon(innerIconPaintParameter);
        }
        else {
            this.iconPainter.paintPentagon(innerIconPaintParameter);
        }
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const referenceOrderedMarkers = [
    exports.ShapeBpmnMarkerKind.LOOP,
    exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_PARALLEL,
    exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_SEQUENTIAL,
    exports.ShapeBpmnMarkerKind.COMPENSATION,
    exports.ShapeBpmnMarkerKind.EXPAND,
    exports.ShapeBpmnMarkerKind.ADHOC,
];
/**
 * @internal
 */
function orderActivityMarkers(markers) {
    const orderedMarkers = referenceOrderedMarkers.filter(marker => markers.includes(marker));
    // Put extra remaining at the end of the ordered markers, in the order they appear in the original array
    markers.filter(marker => !orderedMarkers.includes(marker)).forEach(marker => orderedMarkers.push(marker));
    return orderedMarkers;
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function paintEnvelopeIcon(paintParameter, isFilled) {
    IconPainterProvider.get().paintEnvelopeIcon(Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeft(), ratioFromParent: 0.2, iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: isFilled }) }));
}
/**
 * @internal
 */
class BaseActivityShape extends mxgraph.mxRectangleShape {
    constructor() {
        super(undefined, undefined, undefined); // the configuration is passed with the styles at runtime
        Object.defineProperty(this, "iconPainter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: IconPainterProvider.get()
        });
        // enforced by BPMN
        this.isRounded = true;
    }
    paintForeground(c, x, y, w, h) {
        super.paintForeground(c, x, y, w, h);
        // 0 is used for ratioParent as if we pass undefined to builder function the default 0.25 value will be used instead
        this.paintMarkerIcons(buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this, ratioFromParent: 0, iconStrokeWidth: 1.5 }));
    }
    paintMarkerIcons(paintParameter) {
        const markers = StyleUtils.getBpmnMarkers(this.style);
        if (markers) {
            orderActivityMarkers(markers.split(',')).forEach((marker, idx, allMarkers) => {
                paintParameter = Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: this.getMarkerIconOriginFunction(allMarkers.length, idx + 1) });
                paintParameter.canvas.save(); // ensure we can later restore the configuration
                switch (marker) {
                    case exports.ShapeBpmnMarkerKind.LOOP:
                        this.iconPainter.paintLoopIcon(paintParameter);
                        break;
                    case exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_SEQUENTIAL:
                        this.iconPainter.paintSequentialMultiInstanceIcon(paintParameter);
                        break;
                    case exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_PARALLEL:
                        this.iconPainter.paintParallelMultiInstanceIcon(paintParameter);
                        break;
                    case exports.ShapeBpmnMarkerKind.EXPAND:
                        this.iconPainter.paintExpandIcon(paintParameter);
                        break;
                }
                // Restore original configuration to avoid side effects if the iconPainter changed the canvas configuration (colors, ....)
                paintParameter.canvas.restore();
            });
        }
    }
    getMarkerIconOriginFunction(allMarkers, markerOrder) {
        let setIconOriginFunction;
        if (allMarkers === 1) {
            setIconOriginFunction = (canvas) => canvas.setIconOriginForIconBottomCentered();
        }
        // Here we suppose that we have 'allMarkers === 2'
        // More markers will be supported when implementing adhoc subprocess or compensation marker
        else {
            setIconOriginFunction = (canvas) => {
                canvas.setIconOriginForIconBottomCentered();
                const xTranslation = Math.pow(-1, markerOrder) * (exports.StyleDefault.SHAPE_ACTIVITY_MARKER_ICON_SIZE / 2 + exports.StyleDefault.SHAPE_ACTIVITY_MARKER_ICON_MARGIN);
                canvas.translateIconOrigin(xTranslation, 0);
            };
        }
        return setIconOriginFunction;
    }
}
class BaseTaskShape extends BaseActivityShape {
    paintForeground(c, x, y, w, h) {
        super.paintForeground(c, x, y, w, h);
        this.paintTaskIcon(buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this }));
    }
}
/**
 * @internal
 */
class TaskShape extends BaseTaskShape {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- prefix parameter name - common practice to acknowledge the fact that some parameter is unused (e.g. in TypeScript compiler)
    paintTaskIcon(_paintParameter) {
        // No symbol for the BPMN Task
        this.iconPainter.paintEmptyIcon();
    }
}
/**
 * @internal
 */
class ServiceTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        this.iconPainter.paintGearIcon(Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
    }
}
/**
 * @internal
 */
class UserTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        this.iconPainter.paintPersonIcon(Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
    }
}
/**
 * @internal
 */
class ReceiveTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        if (!StyleUtils.getBpmnIsInstantiating(this.style)) {
            paintEnvelopeIcon(paintParameter, false);
            return;
        }
        const leftMargin = 4;
        const topMargin = 4;
        // paint a fixed size circle
        const circleShapeConfig = Object.assign(Object.assign({}, paintParameter.shapeConfig), { width: 20, height: 20 });
        this.iconPainter.paintCircleIcon({
            canvas: paintParameter.canvas,
            shapeConfig: circleShapeConfig,
            iconStyleConfig: Object.assign(Object.assign({}, paintParameter.iconStyleConfig), { isFilled: false }),
            ratioFromParent: undefined,
            setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeft(topMargin, leftMargin),
        });
        // paint an envelope centered inside the circle, with dimensions proportional to the circle dimensions
        // set the actual origin of the circle icon: this is what 'setIconOriginToShapeTopLeft' has done prior painting the circle icon
        circleShapeConfig.x += leftMargin;
        circleShapeConfig.y += topMargin;
        this.iconPainter.paintEnvelopeIcon(Object.assign(Object.assign({}, paintParameter), { shapeConfig: circleShapeConfig, ratioFromParent: 0.65, setIconOriginFunct: (canvas) => canvas.setIconOriginForIconCentered() }));
    }
}
/**
 * @internal
 */
class SendTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        paintEnvelopeIcon(paintParameter, true);
    }
}
/**
 * @internal
 */
class ManualTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        this.iconPainter.paintHandIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.18, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
    }
}
/**
 * @internal
 */
class ScriptTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        this.iconPainter.paintScriptIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.22, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
    }
}
/**
 * @internal
 */
class CallActivityShape extends BaseActivityShape {
    paintForeground(c, x, y, w, h) {
        super.paintForeground(c, x, y, w, h);
        const paintParameter = buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this });
        switch (StyleUtils.getBpmnGlobalTaskKind(this.style)) {
            case exports.ShapeBpmnElementKind.GLOBAL_TASK_MANUAL:
                this.iconPainter.paintHandIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.18, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
                break;
            case exports.ShapeBpmnElementKind.GLOBAL_TASK_SCRIPT:
                this.iconPainter.paintScriptIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.22, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
                break;
            case exports.ShapeBpmnElementKind.GLOBAL_TASK_USER:
                this.iconPainter.paintPersonIcon(Object.assign(Object.assign({}, paintParameter), { setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(20) }));
                break;
            case exports.ShapeBpmnElementKind.GLOBAL_TASK_BUSINESS_RULE:
                this.iconPainter.paintTableIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.6, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(15) }));
                break;
            case exports.ShapeBpmnElementKind.GLOBAL_TASK:
            default:
                // No symbol for the Call Activity calling a Global Task or calling a Process
                this.iconPainter.paintEmptyIcon();
        }
    }
}
/**
 * @internal
 */
class SubProcessShape extends BaseActivityShape {
    paintBackground(c, x, y, w, h) {
        const subProcessKind = StyleUtils.getBpmnSubProcessKind(this.style);
        c.save(); // ensure we can later restore the configuration
        if (subProcessKind === exports.ShapeBpmnSubProcessKind.EVENT) {
            c.setDashed(true, false);
            c.setDashPattern('1 2');
        }
        super.paintBackground(c, x, y, w, h);
        // Restore original configuration to avoid side effects if the iconPainter changed the canvas configuration (colors, ....)
        c.restore();
    }
}
/**
 * @internal
 */
class BusinessRuleTaskShape extends BaseTaskShape {
    paintTaskIcon(paintParameter) {
        this.iconPainter.paintTableIcon(Object.assign(Object.assign({}, paintParameter), { ratioFromParent: 0.6, setIconOriginFunct: (canvas) => canvas.setIconOriginToShapeTopLeftProportionally(15) }));
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class TextAnnotationShape extends mxgraph.mxRectangleShape {
    paintForeground(c, x, y, _w, h) {
        // paint sort of left square bracket shape - for text annotation
        c.begin();
        c.moveTo(x + exports.StyleDefault.TEXT_ANNOTATION_BORDER_LENGTH, y);
        c.lineTo(x, y);
        c.lineTo(x, y + h);
        c.lineTo(x + exports.StyleDefault.TEXT_ANNOTATION_BORDER_LENGTH, y + h);
        c.stroke();
    }
    paintBackground(c, x, y, w, h) {
        c.save(); // ensure we can later restore the configuration
        c.setStrokeColor('none'); // we have a special stroke shape managed in 'paintForeground'
        super.paintBackground(c, x, y, w, h);
        // Restore original configuration, otherwise 'paintForeground' styles are affected by the style changes done here
        c.restore();
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class MessageFlowIconShape extends mxgraph.mxRectangleShape {
    constructor(bounds, fill, stroke, strokewidth) {
        super(bounds, fill, stroke, strokewidth);
        Object.defineProperty(this, "iconPainter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: IconPainterProvider.get()
        });
    }
    paintVertexShape(c, x, y, w, h) {
        const withFilledIcon = StyleUtils.getBpmnIsInitiating(this.style) === exports.MessageVisibleKind.NON_INITIATING;
        const paintParameter = buildPaintParameter({ canvas: c, x, y, width: w, height: h, shape: this, ratioFromParent: 1, isFilled: withFilledIcon });
        this.iconPainter.paintEnvelopeIcon(paintParameter);
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Compute the all class names associated to a cell in a hyphen case form.
 *
 * @param cell the `mxCell` related to the BPMN element.
 * @param isLabel the boolean that indicates if class must be computed for label.
 * @internal
 */
function computeAllBpmnClassNamesOfCell(cell, isLabel) {
    return computeAllBpmnClassNames(cell.style, isLabel);
}
/**
 * Compute the all class names associated to a given bpmn element in a hyphen case form.
 *
 * @param style the part of the mxCell style related to a {@link BpmnElementKind}. Message flow icon is a special case, as it is not related to `BpmnElementKind`.
 * @param isLabel the boolean that indicates if class must be computed for label.
 * @internal exported for testing purpose
 */
function computeAllBpmnClassNames(style, isLabel) {
    const classes = [];
    const styleElements = style.split(';');
    const pseudoBpmnElementKind = styleElements[0];
    // shape=bpmn.message-flow-icon --> message-flow-icon
    const bpmnElementKind = pseudoBpmnElementKind.replace(/shape=bpmn./g, '');
    const typeClasses = new Map();
    typeClasses.set('bpmn-type-activity', ShapeUtil.isActivity(bpmnElementKind));
    typeClasses.set('bpmn-type-container', ShapeUtil.isPoolOrLane(bpmnElementKind));
    typeClasses.set('bpmn-type-event', ShapeUtil.isEvent(bpmnElementKind));
    typeClasses.set('bpmn-type-flow', isFlowKind(bpmnElementKind));
    typeClasses.set('bpmn-type-gateway', ShapeUtil.isGateway(bpmnElementKind));
    typeClasses.set('bpmn-type-task', ShapeUtil.isTask(bpmnElementKind));
    [...typeClasses].filter(([, isType]) => isType).forEach(([className]) => classes.push(className));
    classes.push(computeBpmnBaseClassName(bpmnElementKind));
    styleElements
        .map(entry => {
        const elements = entry.split('=');
        return [elements[0], elements[1]];
    })
        .forEach(([key, value]) => {
        switch (key) {
            case BpmnStyleIdentifier.EVENT_DEFINITION_KIND:
                classes.push(`bpmn-event-def-${value}`);
                break;
            case BpmnStyleIdentifier.EVENT_BASED_GATEWAY_KIND:
                classes.push(`bpmn-gateway-kind-${value.toLowerCase()}`);
                break;
            case BpmnStyleIdentifier.IS_INITIATING: // message flow icon
                classes.push(value == exports.MessageVisibleKind.NON_INITIATING ? 'bpmn-icon-non-initiating' : 'bpmn-icon-initiating');
                break;
            case BpmnStyleIdentifier.SUB_PROCESS_KIND:
                classes.push(`bpmn-sub-process-${value.toLowerCase()}`);
                break;
            case BpmnStyleIdentifier.GLOBAL_TASK_KIND:
                classes.push(computeBpmnBaseClassName(value));
                break;
        }
    });
    if (isLabel) {
        classes.push('bpmn-label');
    }
    return classes;
}
function isFlowKind(kind) {
    return Object.values(exports.FlowKind)
        .map(value => value)
        .includes(kind);
}
/**
 * Compute the class name in a hyphen case form.
 * For instance, `userTask` returns `bpmn-user-task`
 *
 * @param bpmnElementKind usually, the string representation of a BPMN element kind i.e {@link ShapeBpmnElementKind} and {@link FlowKind}.
 * @internal
 */
function computeBpmnBaseClassName(bpmnElementKind) {
    return !bpmnElementKind ? '' : 'bpmn-' + bpmnElementKind.replace(/([A-Z])/g, g => '-' + g[0].toLowerCase());
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MxGraphCustomOverlay extends mxgraph.mxCellOverlay {
    constructor(label, options) {
        super(null, '', options.position.horizontalAlign, options.position.verticalAlign, null, 'default');
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: label
        });
        Object.defineProperty(this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.style = options.style;
    }
    // Based on original method from mxCellOverlay (mxCellOverlay.prototype.getBounds)
    getBounds(state) {
        const isEdge = state.view.graph.getModel().isEdge(state.cell);
        const s = state.view.scale;
        let pt;
        // START bpmn-visualization CUSTOMIZATION
        // 0 values to position the text overlays on extreme/center points
        const w = 0;
        const h = 0;
        // END bpmn-visualization CUSTOMIZATION
        if (isEdge) {
            pt = this.computeEdgeBounds(state);
        }
        else {
            pt = new mxgraph.mxPoint();
            if (this.align == mxgraph.mxConstants.ALIGN_LEFT) {
                pt.x = state.x;
            }
            else if (this.align == mxgraph.mxConstants.ALIGN_CENTER) {
                pt.x = state.x + state.width / 2;
            }
            else {
                pt.x = state.x + state.width;
            }
            if (this.verticalAlign == mxgraph.mxConstants.ALIGN_TOP) {
                pt.y = state.y;
            }
            else if (this.verticalAlign == mxgraph.mxConstants.ALIGN_MIDDLE) {
                pt.y = state.y + state.height / 2;
            }
            else {
                pt.y = state.y + state.height;
            }
        }
        return new mxgraph.mxRectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);
    }
    computeEdgeBounds(state) {
        const pts = state.absolutePoints;
        // 1st point for start position
        if (this.align == mxgraph.mxConstants.ALIGN_LEFT) {
            return pts[0];
        }
        // middle point for middle position
        else if (this.align == mxgraph.mxConstants.ALIGN_CENTER) {
            if (pts.length % 2 == 1) {
                return pts[Math.floor(pts.length / 2)];
            }
            else {
                const idx = pts.length / 2;
                const p0 = pts[idx - 1];
                const p1 = pts[idx];
                return new mxgraph.mxPoint(p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);
            }
        }
        // last point for end position
        else {
            return pts[pts.length - 1];
        }
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OverlayBadgeShape extends mxgraph.mxText {
    constructor(value, bounds, style) {
        super(value, bounds, undefined, undefined, style.font.color, undefined, style.font.size, undefined, undefined, undefined, undefined, undefined, undefined, undefined, style.fill.color, style.stroke.color);
        this.fillOpacity = style.fill.opacity;
        this.strokewidth = style.stroke.width;
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmnConnector extends mxgraph.mxConnector {
    constructor(points, stroke, strokewidth) {
        super(points, stroke, strokewidth);
    }
    paintEdgeShape(c, pts) {
        // The indirection via functions for markers is needed in
        // order to apply the offsets before painting the line and
        // paint the markers after painting the line.
        const sourceMarker = this.createMarker(c, pts, true);
        const targetMarker = this.createMarker(c, pts, false);
        this.paintEdgeLine(c, pts);
        // Disables shadows, dashed styles
        c.setShadow(false);
        c.setDashed(false, false);
        if (sourceMarker != null) {
            c.setFillColor(mxgraph.mxUtils.getValue(this.style, BpmnStyleIdentifier.EDGE_START_FILL_COLOR, this.stroke));
            sourceMarker();
        }
        if (targetMarker != null) {
            c.setFillColor(mxgraph.mxUtils.getValue(this.style, BpmnStyleIdentifier.EDGE_END_FILL_COLOR, this.stroke));
            targetMarker();
        }
    }
    // taken from mxPolyline, required as we cannot call mxPolyline method here (parent of the parent)
    // we only support non STYLE_CURVED here (is possible with parent class)
    paintEdgeLine(c, pts) {
        const prev = getPointerEventsValue(c);
        setPointerEventsValue(c, 'stroke');
        this.paintLine(c, pts, this.isRounded);
        setPointerEventsValue(c, prev);
    }
}
function getPointerEventsValue(c) {
    return c instanceof mxgraph.mxSvgCanvas2D ? c.pointerEventsValue : null;
}
function setPointerEventsValue(c, value) {
    if (c instanceof mxgraph.mxSvgCanvas2D) {
        c.pointerEventsValue = value;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class ShapeConfigurator {
    configureShapes() {
        this.initMxSvgCanvasPrototype();
        this.initMxShapePrototype();
        this.registerShapes();
        this.initMxCellRendererCreateCellOverlays();
    }
    registerShapes() {
        // events
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.EVENT_END, EndEventShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.EVENT_START, EventShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.EVENT_INTERMEDIATE_THROW, ThrowIntermediateEventShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.EVENT_INTERMEDIATE_CATCH, IntermediateEventShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.EVENT_BOUNDARY, IntermediateEventShape);
        // gateways
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.GATEWAY_COMPLEX, ComplexGatewayShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.GATEWAY_EVENT_BASED, EventBasedGatewayShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.GATEWAY_EXCLUSIVE, ExclusiveGatewayShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.GATEWAY_INCLUSIVE, InclusiveGatewayShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.GATEWAY_PARALLEL, ParallelGatewayShape);
        // activities
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.SUB_PROCESS, SubProcessShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.CALL_ACTIVITY, CallActivityShape);
        // tasks
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK, TaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_SERVICE, ServiceTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_USER, UserTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_RECEIVE, ReceiveTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_SEND, SendTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_MANUAL, ManualTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_SCRIPT, ScriptTaskShape);
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TASK_BUSINESS_RULE, BusinessRuleTaskShape);
        // artifacts
        mxgraph.mxCellRenderer.registerShape(exports.ShapeBpmnElementKind.TEXT_ANNOTATION, TextAnnotationShape);
        // shapes for flows
        mxgraph.mxCellRenderer.registerShape(BpmnStyleIdentifier.EDGE, BpmnConnector);
        mxgraph.mxCellRenderer.registerShape(BpmnStyleIdentifier.MESSAGE_FLOW_ICON, MessageFlowIconShape);
    }
    initMxSvgCanvasPrototype() {
        // getTextCss is only used when creating foreignObject for label, so there is no impact on svg text that we use for Overlays.
        // Analysis done for mxgraph@4.1.1, still apply to mxgraph@4.2.2
        mxgraph.mxSvgCanvas2D.prototype.getTextCss = function () {
            const s = this.state;
            const lh = mxgraph.mxConstants.ABSOLUTE_LINE_HEIGHT ? s.fontSize * mxgraph.mxConstants.LINE_HEIGHT + 'px' : mxgraph.mxConstants.LINE_HEIGHT * this.lineHeightCorrection;
            let css = 'display: inline-block; font-size: ' +
                s.fontSize +
                'px; ' +
                'font-family: ' +
                s.fontFamily +
                '; color: ' +
                s.fontColor +
                '; line-height: ' +
                lh +
                // START Fix for issue #920 (https://github.com/process-analytics/bpmn-visualization-js/issues/920)
                // This cannot be generalized for all mxgraph use cases. For instance, in an editor mode, we should be able to edit the text by clicking on it.
                // Setting to 'none' prevent to capture click.
                '; pointer-events: none' +
                // (this.pointerEvents ? this.pointerEventsValue : 'none') +
                // END OF Fix for issue #920
                '; ';
            if ((s.fontStyle & mxgraph.mxConstants.FONT_BOLD) == mxgraph.mxConstants.FONT_BOLD) {
                css += 'font-weight: bold; ';
            }
            if ((s.fontStyle & mxgraph.mxConstants.FONT_ITALIC) == mxgraph.mxConstants.FONT_ITALIC) {
                css += 'font-style: italic; ';
            }
            const deco = [];
            if ((s.fontStyle & mxgraph.mxConstants.FONT_UNDERLINE) == mxgraph.mxConstants.FONT_UNDERLINE) {
                deco.push('underline');
            }
            if ((s.fontStyle & mxgraph.mxConstants.FONT_STRIKETHROUGH) == mxgraph.mxConstants.FONT_STRIKETHROUGH) {
                deco.push('line-through');
            }
            if (deco.length > 0) {
                css += 'text-decoration: ' + deco.join(' ') + '; ';
            }
            return css;
        };
    }
    initMxShapePrototype() {
        // The following is copied from the mxgraph mxShape implementation then converted to TypeScript and enriched for bpmn-visualization
        // It is needed for adding the custom attributes that permits identification of the BPMN elements in the DOM
        mxgraph.mxShape.prototype.createSvgCanvas = function () {
            const canvas = new mxgraph.mxSvgCanvas2D(this.node, false);
            canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
            canvas.pointerEventsValue = this.svgPointerEvents;
            const off = this.getSvgScreenOffset();
            if (off != 0) {
                this.node.setAttribute('transform', 'translate(' + off + ',' + off + ')');
            }
            else {
                this.node.removeAttribute('transform');
            }
            // START bpmn-visualization CUSTOMIZATION
            // add attributes to be able to identify elements in DOM
            if (this.state && this.state.cell) {
                // 'this.state.style' = the style definition associated with the cell
                // 'this.state.cell.style' = the style applied to the cell: 1st element: style name = bpmn shape name
                const cell = this.state.cell;
                // dialect = strictHtml is set means that current node holds an html label
                let allBpmnClassNames = computeAllBpmnClassNamesOfCell(cell, this.dialect === mxgraph.mxConstants.DIALECT_STRICTHTML);
                const extraCssClasses = this.state.style[BpmnStyleIdentifier.EXTRA_CSS_CLASSES];
                if (extraCssClasses) {
                    allBpmnClassNames = allBpmnClassNames.concat(extraCssClasses);
                }
                this.node.setAttribute('class', allBpmnClassNames.join(' '));
                this.node.setAttribute('data-bpmn-id', this.state.cell.id);
            }
            // END bpmn-visualization CUSTOMIZATION
            canvas.minStrokeWidth = this.minSvgStrokeWidth;
            if (!this.antiAlias) {
                // Rounds all numbers in the SVG output to integers
                canvas.format = function (value) {
                    return Math.round(parseFloat(value));
                };
            }
            return canvas;
        };
    }
    initMxCellRendererCreateCellOverlays() {
        mxgraph.mxCellRenderer.prototype.createCellOverlays = function (state) {
            const graph = state.view.graph;
            const overlays = graph.getCellOverlays(state.cell);
            let dict = null;
            if (overlays != null) {
                dict = new mxgraph.mxDictionary();
                for (const currentOverlay of overlays) {
                    const shape = state.overlays != null ? state.overlays.remove(currentOverlay) : null;
                    if (shape != null) {
                        dict.put(currentOverlay, shape);
                        continue;
                    }
                    let overlayShape;
                    // START bpmn-visualization CUSTOMIZATION
                    if (currentOverlay instanceof MxGraphCustomOverlay) {
                        overlayShape = new OverlayBadgeShape(currentOverlay.label, new mxgraph.mxRectangle(0, 0, 0, 0), currentOverlay.style);
                    }
                    else {
                        overlayShape = new mxgraph.mxImageShape(new mxgraph.mxRectangle(0, 0, 0, 0), currentOverlay.image.src);
                        overlayShape.preserveImageAspect = false;
                    }
                    // END bpmn-visualization CUSTOMIZATION
                    overlayShape.dialect = state.view.graph.dialect;
                    overlayShape.overlay = currentOverlay;
                    // The 'initializeOverlay' signature forces us to hardly cast the overlayShape
                    this.initializeOverlay(state, overlayShape);
                    this.installCellOverlayListeners(state, currentOverlay, overlayShape);
                    if (currentOverlay.cursor != null) {
                        overlayShape.node.style.cursor = currentOverlay.cursor;
                    }
                    // START bpmn-visualization CUSTOMIZATION
                    if (overlayShape instanceof OverlayBadgeShape) {
                        overlayShape.node.classList.add('overlay-badge');
                        overlayShape.node.setAttribute('data-bpmn-id', state.cell.id);
                    }
                    // END bpmn-visualization CUSTOMIZATION
                    dict.put(currentOverlay, overlayShape);
                }
            }
            // Removes unused
            if (state.overlays != null) {
                // prefix parameter name - common practice to acknowledge the fact that some parameter is unused (e.g. in TypeScript compiler)
                state.overlays.visit(function (_id, shape) {
                    shape.destroy();
                });
            }
            state.overlays = dict;
        };
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class MarkerConfigurator {
    configureMarkers() {
        this.registerArrowDashMarker();
    }
    registerArrowDashMarker() {
        // This implementation is adapted from the draw.io BPMN 'dash' marker
        // https://github.com/jgraph/drawio/blob/f539f1ff362e76127dcc7e68b5a9d83dd7d4965c/src/main/webapp/js/mxgraph/Shapes.js#L2796
        // prefix parameter name - common practice to acknowledge the fact that some parameter is unused (e.g. in TypeScript compiler)
        const createMarker = (c, _shape, _type, pe, unitX, unitY, size, _source, strokewidth) => {
            const nx = unitX * (size + strokewidth + 4);
            const ny = unitY * (size + strokewidth + 4);
            return function () {
                c.begin();
                c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
                c.lineTo(pe.x + ny / 2 - (3 * nx) / 2, pe.y - (3 * ny) / 2 - nx / 2);
                c.stroke();
            };
        };
        mxgraph.mxMarker.addMarker(MarkerIdentifier.ARROW_DASH, createMarker);
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
function ensureInRange(value, min, max, defaultValue) {
    let inRangeValue = value == undefined ? defaultValue : value;
    inRangeValue = Math.min(Math.max(inRangeValue, min), max);
    return inRangeValue;
}
/**
 * @internal
 */
function ensurePositiveValue(input) {
    return Math.max(input || 0, 0);
}
/**
 * Make sure the configuration parameters are defined and in range
 * @param config the {@link ZoomConfiguration} to make valid
 * @internal
 */
function ensureValidZoomConfiguration(config) {
    const validatedConfig = config !== null && config !== void 0 ? config : {};
    validatedConfig.debounceDelay = ensureInRange(validatedConfig.debounceDelay, 0, 100, 50);
    validatedConfig.throttleDelay = ensureInRange(validatedConfig.throttleDelay, 0, 100, 50);
    return validatedConfig;
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zoomFactorIn = 1.25;
const zoomFactorOut = 1 / zoomFactorIn;
class BpmnGraph extends mxgraph.mxGraph {
    /**
     * @internal
     */
    constructor(container) {
        super(container);
        Object.defineProperty(this, "currentZoomLevel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        this.zoomFactor = zoomFactorIn;
        if (this.container) {
            // ensure we don't have a select text cursor on label hover, see #294
            this.container.style.cursor = 'default';
        }
    }
    /**
     * @internal
     */
    createGraphView() {
        return new BpmnGraphView(this);
    }
    /**
     * Overridden to manage `currentZoomLevel`
     * @internal
     */
    fit(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight) {
        const scale = super.fit(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight);
        this.setCurrentZoomLevel(scale);
        return scale;
    }
    setCurrentZoomLevel(scale) {
        this.currentZoomLevel = scale !== null && scale !== void 0 ? scale : this.view.scale;
    }
    /**
     * Overridden to manage `currentZoomLevel`
     * @internal
     */
    zoomActual() {
        super.zoomActual();
        this.setCurrentZoomLevel();
    }
    /**
     * Overridden to manage `currentZoomLevel`
     * @internal
     */
    zoomIn() {
        super.zoomIn();
        this.setCurrentZoomLevel();
    }
    /**
     * Overridden to manage `currentZoomLevel`
     * @internal
     */
    zoomOut() {
        super.zoomOut();
        this.setCurrentZoomLevel();
    }
    /**
     * @internal
     */
    customFit(fitOptions) {
        // We should avoid extra zoom/fit reset. See https://github.com/process-analytics/bpmn-visualization-js/issues/888
        this.zoomActual();
        const type = fitOptions === null || fitOptions === void 0 ? void 0 : fitOptions.type;
        if (type == undefined || type == exports.FitType.None) {
            return;
        }
        const margin = ensurePositiveValue(fitOptions === null || fitOptions === void 0 ? void 0 : fitOptions.margin);
        if (type != exports.FitType.Center) {
            let ignoreWidth = false;
            let ignoreHeight = false;
            switch (type) {
                case exports.FitType.Horizontal:
                    ignoreHeight = true;
                    break;
                case exports.FitType.Vertical:
                    ignoreWidth = true;
                    break;
            }
            this.fit(this.border, false, margin, true, ignoreWidth, ignoreHeight);
        }
        else {
            // Inspired from https://jgraph.github.io/mxgraph/docs/js-api/files/view/mxGraph-js.html#mxGraph.fit
            const maxScale = 3;
            const bounds = this.getGraphBounds();
            const clientWidth = this.container.clientWidth - margin;
            const clientHeight = this.container.clientHeight - margin;
            const width = bounds.width / this.view.scale;
            const height = bounds.height / this.view.scale;
            const scale = Math.min(maxScale, Math.min(clientWidth / width, clientHeight / height));
            this.setCurrentZoomLevel(scale);
            this.view.scaleAndTranslate(scale, (margin + clientWidth - width * scale) / (2 * scale) - bounds.x / this.view.scale, (margin + clientHeight - height * scale) / (2 * scale) - bounds.y / this.view.scale);
        }
    }
    /**
     * @internal
     */
    registerMouseWheelZoomListeners(config) {
        config = ensureValidZoomConfiguration(config);
        mxgraph.mxEvent.addMouseWheelListener(debounce__default["default"](this.createMouseWheelZoomListener(true), config.debounceDelay), this.container);
        mxgraph.mxEvent.addMouseWheelListener(throttle__default["default"](this.createMouseWheelZoomListener(false), config.throttleDelay), this.container);
    }
    // Update the currentZoomLevel when performScaling is false, use the currentZoomLevel to set the scale otherwise
    // Initial implementation inspired by https://github.com/algenty/grafana-flowcharting/blob/0.9.0/src/graph_class.ts#L1254
    manageMouseWheelZoomEvent(up, evt, performScaling) {
        if (!performScaling) {
            this.currentZoomLevel *= up ? zoomFactorIn : zoomFactorOut;
        }
        else {
            const [offsetX, offsetY] = this.getEventRelativeCoordinates(evt);
            const [newScale, dx, dy] = this.getScaleAndTranslationDeltas(offsetX, offsetY);
            this.view.scaleAndTranslate(newScale, this.view.translate.x + dx, this.view.translate.y + dy);
            mxgraph.mxEvent.consume(evt);
        }
    }
    createMouseWheelZoomListener(performScaling) {
        return (event, up) => {
            if (mxgraph.mxEvent.isConsumed(event)) {
                return;
            }
            const evt = event;
            // only the ctrl key
            const isZoomWheelEvent = evt.ctrlKey && !evt.altKey && !evt.shiftKey && !evt.metaKey;
            if (isZoomWheelEvent) {
                this.manageMouseWheelZoomEvent(up, evt, performScaling);
            }
        };
    }
    getEventRelativeCoordinates(evt) {
        const rect = this.container.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        return [x, y];
    }
    getScaleAndTranslationDeltas(offsetX, offsetY) {
        const [factor, scale] = this.calculateFactorAndScale();
        const [dx, dy] = this.calculateTranslationDeltas(factor, scale, offsetX * 2, offsetY * 2);
        return [scale, dx, dy];
    }
    // solution inspired by https://github.com/jgraph/mxgraph/blob/v4.2.2/javascript/src/js/view/mxGraph.js#L8074-L8085
    calculateTranslationDeltas(factor, scale, dx, dy) {
        if (factor > 1) {
            const f = (factor - 1) / (scale * 2);
            dx *= -f;
            dy *= -f;
        }
        else {
            const f = (1 / factor - 1) / (this.view.scale * 2);
            dx *= f;
            dy *= f;
        }
        return [dx, dy];
    }
    calculateFactorAndScale() {
        // Rounded in the same way as in the mxGraph.zoom function for consistency.
        const scale = Math.round(this.currentZoomLevel * 100) / 100;
        const factor = scale / this.view.scale;
        return [factor, scale];
    }
}
class BpmnGraphView extends mxgraph.mxGraphView {
    getFloatingTerminalPoint(edge, start, end, source) {
        // some values may be null: the first and the last values are null prior computing floating terminal points
        const edgePoints = edge.absolutePoints.filter(Boolean);
        // when there is no BPMN waypoint, all values are null
        const needsFloatingTerminalPoint = edgePoints.length < 2;
        if (needsFloatingTerminalPoint) {
            return super.getFloatingTerminalPoint(edge, start, end, source);
        }
        const pts = edge.absolutePoints;
        return source ? pts[1] : pts[pts.length - 2];
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Configure the BpmnMxGraph graph that can be used by the lib
 * <ul>
 *     <li>styles
 *     <li>shapes
 *     <li>markers
 * @internal
 */
class GraphConfigurator {
    constructor(container) {
        Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: container
        });
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.graph = new BpmnGraph(container);
    }
    configure(options) {
        this.configureGraph();
        this.configureNavigationSupport(options);
        new StyleConfigurator(this.graph).configureStyles();
        new ShapeConfigurator().configureShapes();
        new MarkerConfigurator().configureMarkers();
        return this.graph;
    }
    configureGraph() {
        this.graph.setCellsLocked(true);
        this.graph.setCellsSelectable(false);
        this.graph.setEdgeLabelsMovable(false);
        this.graph.setHtmlLabels(true); // required for wrapping
        // To have the boundary event on the border of a task
        this.graph.setConstrainChildren(false);
        this.graph.setExtendParents(false);
        // Disable folding for container mxCell (pool, lane, sub process, call activity) because we don't need it.
        // This also prevents requesting unavailable images (see #185) as we don't override BpmnMxGraph folding default images.
        this.graph.foldingEnabled = false;
    }
    configureNavigationSupport(options) {
        var _a;
        const panningHandler = this.graph.panningHandler;
        if ((_a = options === null || options === void 0 ? void 0 : options.navigation) === null || _a === void 0 ? void 0 : _a.enabled) {
            // Pan configuration
            panningHandler.addListener(mxgraph.mxEvent.PAN_START, this.getPanningHandler('grab'));
            panningHandler.addListener(mxgraph.mxEvent.PAN_END, this.getPanningHandler('default'));
            this.graph.panningHandler.usePopupTrigger = false; // only use the left button to trigger panning
            // Reimplement the function as we also want to trigger 'panning on cells' (ignoreCell to true) and only on left-click
            // The mxGraph standard implementation doesn't ignore right click in this case, so do it by ourselves
            panningHandler.isForcePanningEvent = (me) => mxgraph.mxEvent.isLeftMouseButton(me.getEvent()) || mxgraph.mxEvent.isMultiTouchEvent(me.getEvent());
            this.graph.setPanning(true);
            // Zoom configuration
            this.graph.registerMouseWheelZoomListeners(options.navigation.zoom);
        }
        else {
            this.graph.setPanning(false);
            // Disable gesture support for zoom
            panningHandler.setPinchEnabled(false);
            // Disable panning on touch device
            // eslint-disable-next-line @typescript-eslint/no-unused-vars -- prefix parameter name - common practice to acknowledge the fact that some parameter is unused (e.g. in TypeScript compiler)
            panningHandler.isForcePanningEvent = (_me) => false;
        }
    }
    getPanningHandler(cursor) {
        return () => {
            this.graph.isEnabled() && (this.container.style.cursor = cursor);
        };
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class Flow {
    constructor(id, name, kind, sourceRefId, targetRefId) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: kind
        });
        Object.defineProperty(this, "sourceRefId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sourceRefId
        });
        Object.defineProperty(this, "targetRefId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: targetRefId
        });
    }
}
/**
 * @internal
 */
class SequenceFlow extends Flow {
    constructor(id, name, sourceRefId, targetRefId, sequenceFlowKind = exports.SequenceFlowKind.NORMAL) {
        super(id, name, exports.FlowKind.SEQUENCE_FLOW, sourceRefId, targetRefId);
        Object.defineProperty(this, "sequenceFlowKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sequenceFlowKind
        });
    }
}
/**
 * @internal
 */
class MessageFlow extends Flow {
    constructor(id, name, sourceRefId, targetRefId) {
        super(id, name, exports.FlowKind.MESSAGE_FLOW, sourceRefId, targetRefId);
    }
}
/**
 * @internal
 */
class AssociationFlow extends Flow {
    constructor(id, name, sourceRefId, targetRefId, associationDirectionKind = exports.AssociationDirectionKind.NONE) {
        super(id, name, exports.FlowKind.ASSOCIATION_FLOW, sourceRefId, targetRefId);
        Object.defineProperty(this, "associationDirectionKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: associationDirectionKind
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class CoordinatesTranslator {
    constructor(graph) {
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graph
        });
    }
    /**
     * Compute an absolute coordinate in relative coordinates in the parent cell referential.
     * @param parent the cell to use for the new coordinate referential
     * @param absoluteCoordinate
     */
    computeRelativeCoordinates(parent, absoluteCoordinate) {
        const translateForRoot = this.getTranslateForRoot(parent);
        const relativeX = absoluteCoordinate.x + translateForRoot.x;
        const relativeY = absoluteCoordinate.y + translateForRoot.y;
        return new mxgraph.mxPoint(relativeX, relativeY);
    }
    // Returns the translation to be applied to a cell whose mxGeometry x and y values are expressed with absolute coordinates
    // (i.e related to the graph default parent) you want to assign as parent to the cell passed as argument of this function.
    // That way, you will be able to express the cell coordinates as relative to its parent cell.
    //
    // This implementation is taken from the example described in the documentation of mxgraph#getTranslateForRoot (4.1.1)
    // The translation is generally negative
    getTranslateForRoot(cell) {
        const model = this.graph.getModel();
        const offset = new mxgraph.mxPoint(0, 0);
        while (cell != null) {
            const geo = model.getGeometry(cell);
            if (geo != null) {
                offset.x -= geo.x;
                offset.y -= geo.y;
            }
            cell = model.getParent(cell);
        }
        return offset;
    }
    /**
     * Compute the center of the provided `mxCell` for absolute geometry: this is the center point of a segment whose edges
     * are the terminal points of the mxCell geometry points. Returns `undefined` if the 2 terminal points are not available.
     *
     * The center coordinates are given in the same referential as the `mxCell`, so relative to its parent.
     */
    computeEdgeCenter(mxEdge) {
        const points = mxEdge.geometry.points;
        const p0 = points[0];
        const pe = points[points.length - 1];
        if (p0 != null && pe != null) {
            const dx = pe.x - p0.x;
            const dy = pe.y - p0.y;
            return new mxgraph.mxPoint(p0.x + dx / 2, p0.y + dy / 2);
        }
        return undefined;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class Shape {
    constructor(id, bpmnElement, bounds, label, isHorizontal) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "bpmnElement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnElement
        });
        Object.defineProperty(this, "bounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bounds
        });
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: label
        });
        Object.defineProperty(this, "isHorizontal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isHorizontal
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class ShapeBpmnElement {
    constructor(id, name, kind, parentId, instantiate = false) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: kind
        });
        Object.defineProperty(this, "parentId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parentId
        });
        Object.defineProperty(this, "instantiate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: instantiate
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnActivity extends ShapeBpmnElement {
    constructor(id, name, kind, parentId, instantiate, markers = []) {
        super(id, name, kind, parentId, instantiate);
        Object.defineProperty(this, "markers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: markers
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnCallActivity extends ShapeBpmnActivity {
    constructor(id, name, callActivityKind, parentId, markers, globalTaskKind) {
        super(id, name, exports.ShapeBpmnElementKind.CALL_ACTIVITY, parentId, undefined, markers);
        Object.defineProperty(this, "callActivityKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: callActivityKind
        });
        Object.defineProperty(this, "globalTaskKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: globalTaskKind
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnSubProcess extends ShapeBpmnActivity {
    constructor(id, name, subProcessKind, parentId, markers) {
        super(id, name, exports.ShapeBpmnElementKind.SUB_PROCESS, parentId, undefined, markers);
        Object.defineProperty(this, "subProcessKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: subProcessKind
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnEvent extends ShapeBpmnElement {
    constructor(id, name, elementKind, eventDefinitionKind, parentId) {
        super(id, name, elementKind, parentId);
        Object.defineProperty(this, "eventDefinitionKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: eventDefinitionKind
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnStartEvent extends ShapeBpmnEvent {
    constructor(id, name, eventDefinitionKind, parentId, isInterrupting) {
        super(id, name, exports.ShapeBpmnElementKind.EVENT_START, eventDefinitionKind, parentId);
        Object.defineProperty(this, "isInterrupting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isInterrupting
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnBoundaryEvent extends ShapeBpmnEvent {
    constructor(id, name, eventDefinitionKind, parentId, isInterrupting = true) {
        super(id, name, exports.ShapeBpmnElementKind.EVENT_BOUNDARY, eventDefinitionKind, parentId);
        Object.defineProperty(this, "isInterrupting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isInterrupting
        });
    }
}
/**
 * @internal
 */
class ShapeBpmnEventBasedGateway extends ShapeBpmnElement {
    constructor(id, name, parentId, instantiate, gatewayKind = exports.ShapeBpmnEventBasedGatewayKind.None) {
        super(id, name, exports.ShapeBpmnElementKind.GATEWAY_EVENT_BASED, parentId, instantiate);
        Object.defineProperty(this, "gatewayKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: gatewayKind
        });
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class StyleComputer {
    computeStyle(bpmnCell, labelBounds) {
        const styles = [bpmnCell.bpmnElement.kind];
        let shapeStyleValues;
        if (bpmnCell instanceof Shape) {
            shapeStyleValues = StyleComputer.computeShapeStyle(bpmnCell);
        }
        else {
            styles.push(...StyleComputer.computeEdgeStyle(bpmnCell));
            shapeStyleValues = new Map();
        }
        const fontStyleValues = StyleComputer.computeFontStyleValues(bpmnCell);
        const labelStyleValues = StyleComputer.computeLabelStyleValues(bpmnCell, labelBounds);
        return [] //
            .concat([...styles])
            .concat([...shapeStyleValues, ...fontStyleValues, ...labelStyleValues].filter(([, v]) => v && v != 'undefined').map(([key, value]) => key + '=' + value))
            .join(';');
    }
    static computeShapeStyle(shape) {
        const styleValues = new Map();
        const bpmnElement = shape.bpmnElement;
        if (bpmnElement instanceof ShapeBpmnEvent) {
            this.computeEventShapeStyle(bpmnElement, styleValues);
        }
        else if (bpmnElement instanceof ShapeBpmnActivity) {
            this.computeActivityShapeStyle(bpmnElement, styleValues);
        }
        else if (ShapeUtil.isPoolOrLane(bpmnElement.kind)) {
            // mxgraph.mxConstants.STYLE_HORIZONTAL is for the label
            // In BPMN, isHorizontal is for the Shape
            styleValues.set(mxgraph.mxConstants.STYLE_HORIZONTAL, shape.isHorizontal ? '0' : '1');
        }
        else if (bpmnElement instanceof ShapeBpmnEventBasedGateway) {
            styleValues.set(BpmnStyleIdentifier.IS_INSTANTIATING, String(bpmnElement.instantiate));
            styleValues.set(BpmnStyleIdentifier.EVENT_BASED_GATEWAY_KIND, String(bpmnElement.gatewayKind));
        }
        return styleValues;
    }
    static computeEventShapeStyle(bpmnElement, styleValues) {
        styleValues.set(BpmnStyleIdentifier.EVENT_DEFINITION_KIND, bpmnElement.eventDefinitionKind);
        if (bpmnElement instanceof ShapeBpmnBoundaryEvent || (bpmnElement instanceof ShapeBpmnStartEvent && bpmnElement.isInterrupting !== undefined)) {
            styleValues.set(BpmnStyleIdentifier.IS_INTERRUPTING, String(bpmnElement.isInterrupting));
        }
    }
    static computeActivityShapeStyle(bpmnElement, styleValues) {
        if (bpmnElement instanceof ShapeBpmnSubProcess) {
            styleValues.set(BpmnStyleIdentifier.SUB_PROCESS_KIND, bpmnElement.subProcessKind);
        }
        else if (bpmnElement.kind === exports.ShapeBpmnElementKind.TASK_RECEIVE) {
            styleValues.set(BpmnStyleIdentifier.IS_INSTANTIATING, String(bpmnElement.instantiate));
        }
        else if (bpmnElement instanceof ShapeBpmnCallActivity) {
            styleValues.set(BpmnStyleIdentifier.GLOBAL_TASK_KIND, bpmnElement.globalTaskKind);
        }
        const markers = bpmnElement.markers;
        if (markers.length > 0) {
            styleValues.set(BpmnStyleIdentifier.MARKERS, markers.join(','));
        }
    }
    static computeEdgeStyle(edge) {
        const styles = [];
        const bpmnElement = edge.bpmnElement;
        if (bpmnElement instanceof SequenceFlow) {
            styles.push(bpmnElement.sequenceFlowKind);
        }
        if (bpmnElement instanceof AssociationFlow) {
            styles.push(bpmnElement.associationDirectionKind);
        }
        return styles;
    }
    static computeFontStyleValues(bpmnCell) {
        var _a;
        const styleValues = new Map();
        const font = (_a = bpmnCell.label) === null || _a === void 0 ? void 0 : _a.font;
        if (font) {
            styleValues.set(mxgraph.mxConstants.STYLE_FONTFAMILY, font.name);
            styleValues.set(mxgraph.mxConstants.STYLE_FONTSIZE, font.size);
            styleValues.set(mxgraph.mxConstants.STYLE_FONTSTYLE, StyleComputer.getFontStyleValue(font));
        }
        return styleValues;
    }
    static computeLabelStyleValues(bpmnCell, labelBounds) {
        const styleValues = new Map();
        const bpmnElement = bpmnCell.bpmnElement;
        if (labelBounds) {
            styleValues.set(mxgraph.mxConstants.STYLE_VERTICAL_ALIGN, mxgraph.mxConstants.ALIGN_TOP);
            if (bpmnCell.bpmnElement.kind != exports.ShapeBpmnElementKind.TEXT_ANNOTATION) {
                styleValues.set(mxgraph.mxConstants.STYLE_ALIGN, mxgraph.mxConstants.ALIGN_CENTER);
            }
            if (bpmnCell instanceof Shape) {
                // arbitrarily increase width to relax too small bounds (for instance for reference diagrams from miwg-test-suite)
                styleValues.set(mxgraph.mxConstants.STYLE_LABEL_WIDTH, labelBounds.width + 1);
                // align settings
                styleValues.set(mxgraph.mxConstants.STYLE_LABEL_POSITION, mxgraph.mxConstants.ALIGN_TOP);
                styleValues.set(mxgraph.mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxgraph.mxConstants.ALIGN_LEFT);
            }
        }
        // when no label bounds, adjust the default style dynamically
        else if (bpmnCell instanceof Shape &&
            (bpmnElement instanceof ShapeBpmnSubProcess ||
                (bpmnElement instanceof ShapeBpmnCallActivity && bpmnElement.callActivityKind === exports.ShapeBpmnCallActivityKind.CALLING_PROCESS)) &&
            !bpmnElement.markers.includes(exports.ShapeBpmnMarkerKind.EXPAND)) {
            styleValues.set(mxgraph.mxConstants.STYLE_VERTICAL_ALIGN, mxgraph.mxConstants.ALIGN_TOP);
        }
        return styleValues;
    }
    computeMessageFlowIconStyle(edge) {
        return `shape=${BpmnStyleIdentifier.MESSAGE_FLOW_ICON};${BpmnStyleIdentifier.IS_INITIATING}=${edge.messageVisibleKind}`;
    }
    static getFontStyleValue(font) {
        let value = 0;
        if (font.isBold) {
            value += mxgraph.mxConstants.FONT_BOLD;
        }
        if (font.isItalic) {
            value += mxgraph.mxConstants.FONT_ITALIC;
        }
        if (font.isStrikeThrough) {
            value += mxgraph.mxConstants.FONT_STRIKETHROUGH;
        }
        if (font.isUnderline) {
            value += mxgraph.mxConstants.FONT_UNDERLINE;
        }
        return value;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class BpmnRenderer {
    constructor(graph, coordinatesTranslator, styleComputer) {
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graph
        });
        Object.defineProperty(this, "coordinatesTranslator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: coordinatesTranslator
        });
        Object.defineProperty(this, "styleComputer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: styleComputer
        });
    }
    render(renderedModel, fitOptions) {
        this.insertShapesAndEdges(renderedModel);
        this.graph.customFit(fitOptions);
    }
    insertShapesAndEdges({ pools, lanes, subprocesses, otherFlowNodes, boundaryEvents, edges }) {
        const model = this.graph.getModel();
        model.clear(); // ensure to remove manual changes or already loaded graphs
        model.beginUpdate();
        try {
            this.insertShapes(pools);
            this.insertShapes(lanes);
            this.insertShapes(subprocesses);
            this.insertShapes(otherFlowNodes);
            // last shape as the boundary event parent must be in the model (subprocess or activity)
            this.insertShapes(boundaryEvents);
            // at last as edge source and target must be present in the model prior insertion, otherwise they are not rendered
            this.insertEdges(edges);
        }
        finally {
            model.endUpdate();
        }
    }
    insertShapes(shapes) {
        shapes.forEach(shape => this.insertShape(shape));
    }
    getParent(bpmnElement) {
        const bpmnElementParent = this.getCell(bpmnElement.parentId);
        return bpmnElementParent !== null && bpmnElementParent !== void 0 ? bpmnElementParent : this.graph.getDefaultParent();
    }
    insertShape(shape) {
        var _a;
        const bpmnElement = shape.bpmnElement;
        const parent = this.getParent(bpmnElement);
        const bounds = shape.bounds;
        let labelBounds = (_a = shape.label) === null || _a === void 0 ? void 0 : _a.bounds;
        // pool/lane label bounds are not managed for now (use hard coded values)
        labelBounds = ShapeUtil.isPoolOrLane(bpmnElement.kind) ? undefined : labelBounds;
        const style = this.styleComputer.computeStyle(shape, labelBounds);
        this.insertVertex(parent, bpmnElement.id, bpmnElement.name, bounds, labelBounds, style);
    }
    insertEdges(edges) {
        edges.forEach(edge => {
            var _a;
            const bpmnElement = edge.bpmnElement;
            const parent = this.graph.getDefaultParent();
            const source = this.getCell(bpmnElement.sourceRefId);
            const target = this.getCell(bpmnElement.targetRefId);
            const labelBounds = (_a = edge.label) === null || _a === void 0 ? void 0 : _a.bounds;
            const style = this.styleComputer.computeStyle(edge, labelBounds);
            const mxEdge = this.graph.insertEdge(parent, bpmnElement.id, bpmnElement.name, source, target, style);
            this.insertWaypoints(edge.waypoints, mxEdge);
            if (labelBounds) {
                mxEdge.geometry.width = labelBounds.width;
                mxEdge.geometry.height = labelBounds.height;
                const edgeCenterCoordinate = this.coordinatesTranslator.computeEdgeCenter(mxEdge);
                if (edgeCenterCoordinate) {
                    mxEdge.geometry.relative = false;
                    const labelBoundsRelativeCoordinateFromParent = this.coordinatesTranslator.computeRelativeCoordinates(mxEdge.parent, new mxgraph.mxPoint(labelBounds.x, labelBounds.y));
                    const relativeLabelX = labelBoundsRelativeCoordinateFromParent.x + labelBounds.width / 2 - edgeCenterCoordinate.x;
                    const relativeLabelY = labelBoundsRelativeCoordinateFromParent.y - edgeCenterCoordinate.y;
                    mxEdge.geometry.offset = new mxgraph.mxPoint(relativeLabelX, relativeLabelY);
                }
            }
            this.insertMessageFlowIconIfNeeded(edge, mxEdge);
        });
    }
    insertMessageFlowIconIfNeeded(edge, mxEdge) {
        if (edge.bpmnElement instanceof MessageFlow && edge.messageVisibleKind !== exports.MessageVisibleKind.NONE) {
            const cell = this.graph.insertVertex(mxEdge, messageFowIconId(mxEdge.id), undefined, 0, 0, 20, 14, this.styleComputer.computeMessageFlowIconStyle(edge));
            cell.geometry.relative = true;
            cell.geometry.offset = new mxgraph.mxPoint(-10, -7);
        }
    }
    insertWaypoints(waypoints, mxEdge) {
        if (waypoints) {
            mxEdge.geometry.points = waypoints.map(waypoint => this.coordinatesTranslator.computeRelativeCoordinates(mxEdge.parent, new mxgraph.mxPoint(waypoint.x, waypoint.y)));
        }
    }
    getCell(id) {
        return this.graph.getModel().getCell(id);
    }
    insertVertex(parent, id, value, bounds, labelBounds, style) {
        const vertexCoordinates = this.coordinatesTranslator.computeRelativeCoordinates(parent, new mxgraph.mxPoint(bounds.x, bounds.y));
        const cell = this.graph.insertVertex(parent, id, value, vertexCoordinates.x, vertexCoordinates.y, bounds.width, bounds.height, style);
        if (labelBounds) {
            // label coordinates are relative in the cell referential coordinates
            const relativeLabelX = labelBounds.x - bounds.x;
            const relativeLabelY = labelBounds.y - bounds.y;
            cell.geometry.offset = new mxgraph.mxPoint(relativeLabelX, relativeLabelY);
        }
        return cell;
    }
}
/**
 * @internal
 */
function newBpmnRenderer(graph) {
    return new BpmnRenderer(graph, new CoordinatesTranslator(graph), new StyleComputer());
}
/**
 * @internal
 */
function messageFowIconId(messageFlowId) {
    return `messageFlowIcon_of_${messageFlowId}`;
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse bpmn xml source
 * @internal
 */
class BpmnXmlParser {
    constructor() {
        Object.defineProperty(this, "x2jOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                attributeNamePrefix: '',
                removeNSPrefix: true,
                ignoreAttributes: false,
                parseAttributeValue: true,
                // entities management
                processEntities: false,
                attributeValueProcessor: (_name, val) => {
                    return entities.decodeXML(val);
                },
            }
        });
        Object.defineProperty(this, "xmlParser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new fastXmlParser.XMLParser(this.x2jOptions)
        });
    }
    parse(xml) {
        let model;
        try {
            model = this.xmlParser.parse(xml);
        }
        catch (_a) {
            throw new Error('XML parsing failed. Invalid BPMN source.');
        }
        if (!model.definitions) {
            // We currently don't validate the xml, so we don't detect xml validation error
            // if 'definitions' is undefined, there is an Error later in the parsing code without explicit information
            // So for now, throw a generic error that better explains the problem.
            // See https://github.com/process-analytics/bpmn-visualization-js/issues/21 for improvement
            throw new Error(`XML parsing failed. Unable to retrieve 'definitions' from the BPMN source.`);
        }
        return model;
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JsonParsingWarning {
}
class ParsingMessageCollector {
    warning(warning) {
        const message = warning.getMessage();
        console.warn(message.template, ...message.arguments);
    }
}

class GroupUnknownCategoryValueWarning extends JsonParsingWarning {
    constructor(groupBpmnElementId, categoryValueRef) {
        super();
        Object.defineProperty(this, "groupBpmnElementId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: groupBpmnElementId
        });
        Object.defineProperty(this, "categoryValueRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: categoryValueRef
        });
    }
    getMessage() {
        return {
            arguments: [this.categoryValueRef, this.groupBpmnElementId],
            template: 'Group json deserialization: unable to find category value ref %s for bpmn element %s',
        };
    }
}
class ShapeUnknownBpmnElementWarning extends JsonParsingWarning {
    constructor(bpmnElementId) {
        super();
        Object.defineProperty(this, "bpmnElementId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnElementId
        });
    }
    getMessage() {
        return {
            arguments: [this.bpmnElementId],
            template: 'Shape json deserialization: unable to find bpmn element with id %s',
        };
    }
}
class EdgeUnknownBpmnElementWarning extends JsonParsingWarning {
    constructor(bpmnElementId) {
        super();
        Object.defineProperty(this, "bpmnElementId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnElementId
        });
    }
    getMessage() {
        return {
            arguments: [this.bpmnElementId],
            template: 'Edge json deserialization: unable to find bpmn element with id %s',
        };
    }
}
class LabelStyleMissingFontWarning extends JsonParsingWarning {
    constructor(shapeOrEdgeId, labelStyleId) {
        super();
        Object.defineProperty(this, "shapeOrEdgeId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: shapeOrEdgeId
        });
        Object.defineProperty(this, "labelStyleId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: labelStyleId
        });
    }
    getMessage() {
        return {
            arguments: [this.labelStyleId, this.shapeOrEdgeId],
            template: 'Unable to assign font from style %s to shape/edge %s',
        };
    }
}
class LaneUnknownFlowNodeRefWarning extends JsonParsingWarning {
    constructor(laneId, flowNodeRef) {
        super();
        Object.defineProperty(this, "laneId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: laneId
        });
        Object.defineProperty(this, "flowNodeRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: flowNodeRef
        });
    }
    getMessage() {
        return {
            arguments: [this.flowNodeRef, this.laneId],
            template: 'Unable to assign lane %s as parent: flow node %s is not found',
        };
    }
}
class BoundaryEventNotAttachedToActivityWarning extends JsonParsingWarning {
    constructor(bpmnElementId, attachedToRef, attachedToKind) {
        super();
        Object.defineProperty(this, "bpmnElementId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnElementId
        });
        Object.defineProperty(this, "attachedToRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: attachedToRef
        });
        Object.defineProperty(this, "attachedToKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: attachedToKind
        });
    }
    getMessage() {
        return {
            arguments: [this.bpmnElementId, this.attachedToRef, this.attachedToKind],
            template: 'The boundary event %s must be attached to an activity, and not to %s of kind %s',
        };
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class ConvertedElements {
    constructor() {
        Object.defineProperty(this, "poolsById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "poolsByProcessRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "messageFlows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "flowNodes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "lanes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "sequenceFlows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "associationFlows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "eventDefinitionsOfDefinitions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "globalTasks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "categoryValues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    findPoolById(id) {
        return this.poolsById.get(id);
    }
    findPoolByProcessRef(processRef) {
        return this.poolsByProcessRef.get(processRef);
    }
    registerPool(pool, processRef) {
        this.poolsById.set(pool.id, pool);
        if (processRef) {
            this.poolsByProcessRef.set(processRef, pool);
        }
    }
    findMessageFlow(id) {
        return this.messageFlows.get(id);
    }
    registerMessageFlow(messageFlow) {
        this.messageFlows.set(messageFlow.id, messageFlow);
    }
    findFlowNode(id) {
        return this.flowNodes.get(id);
    }
    registerFlowNode(flowNode) {
        this.flowNodes.set(flowNode.id, flowNode);
    }
    findLane(id) {
        return this.lanes.get(id);
    }
    registerLane(lane) {
        this.lanes.set(lane.id, lane);
    }
    findSequenceFlow(id) {
        return this.sequenceFlows.get(id);
    }
    registerSequenceFlow(sequenceFlow) {
        this.sequenceFlows.set(sequenceFlow.id, sequenceFlow);
    }
    findAssociationFlow(id) {
        return this.associationFlows.get(id);
    }
    registerAssociationFlow(associationFlow) {
        this.associationFlows.set(associationFlow.id, associationFlow);
    }
    findEventDefinitionOfDefinition(id) {
        return this.eventDefinitionsOfDefinitions.get(id);
    }
    registerEventDefinitionsOfDefinition(id, eventDefinition) {
        this.eventDefinitionsOfDefinitions.set(id, eventDefinition);
    }
    findGlobalTask(id) {
        return this.globalTasks.get(id);
    }
    registerGlobalTask(id, kind) {
        this.globalTasks.set(id, kind);
    }
    findCategoryValue(categoryValue) {
        return this.categoryValues.get(categoryValue);
    }
    registerCategoryValue(id, value) {
        this.categoryValues.set(id, { value });
    }
}
const buildShapeBpmnGroup = (convertedElements, parsingMessageCollector, groupBpmnElement, processId) => {
    const categoryValueData = convertedElements.findCategoryValue(groupBpmnElement.categoryValueRef);
    if (categoryValueData) {
        return new ShapeBpmnElement(groupBpmnElement.id, categoryValueData.value, exports.ShapeBpmnElementKind.GROUP, processId);
    }
    parsingMessageCollector.warning(new GroupUnknownCategoryValueWarning(groupBpmnElement.id, groupBpmnElement.categoryValueRef));
    return undefined;
};

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class CollaborationConverter {
    constructor(convertedElements, parsingMessageCollector) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
        Object.defineProperty(this, "parsingMessageCollector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parsingMessageCollector
        });
    }
    deserialize(collaborations) {
        ensureIsArray(collaborations).forEach(collaboration => this.parseCollaboration(collaboration));
    }
    parseCollaboration(collaboration) {
        this.buildParticipant(collaboration.participant);
        this.buildMessageFlows(collaboration.messageFlow);
        this.buildGroups(collaboration.group);
    }
    buildParticipant(bpmnElements) {
        ensureIsArray(bpmnElements).forEach(participant => this.convertedElements.registerPool(new ShapeBpmnElement(participant.id, participant.name, exports.ShapeBpmnElementKind.POOL), participant.processRef));
    }
    buildMessageFlows(bpmnElements) {
        ensureIsArray(bpmnElements).forEach(messageFlow => this.convertedElements.registerMessageFlow(new MessageFlow(messageFlow.id, messageFlow.name, messageFlow.sourceRef, messageFlow.targetRef)));
    }
    buildGroups(bpmnElements) {
        ensureIsArray(bpmnElements).forEach(groupBpmnElement => {
            const shapeBpmnElement = buildShapeBpmnGroup(this.convertedElements, this.parsingMessageCollector, groupBpmnElement);
            shapeBpmnElement && this.convertedElements.registerFlowNode(shapeBpmnElement);
        });
    }
}

/* eslint-disable @typescript-eslint/ban-ts-comment */
/**
 * @internal
 */
class ProcessConverter {
    constructor(convertedElements, parsingMessageCollector) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
        Object.defineProperty(this, "parsingMessageCollector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parsingMessageCollector
        });
        Object.defineProperty(this, "defaultSequenceFlowIds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "elementsWithoutParentByProcessId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "callActivitiesCallingProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    deserialize(processes) {
        ensureIsArray(processes).forEach(process => this.parseProcess(process));
        // Need to call this after all processes have been parsed, because to link a call activity to the elements of the called process, we have to parse all processes before.
        ensureIsArray(processes).forEach(process => this.assignParentOfProcessElementsCalledByCallActivity(process.id));
    }
    assignParentOfProcessElementsCalledByCallActivity(processId) {
        const callActivity = this.callActivitiesCallingProcess.get(processId);
        if (callActivity) {
            const pool = this.convertedElements.findPoolByProcessRef(processId);
            if (pool) {
                pool.parentId = callActivity.id;
            }
            this.elementsWithoutParentByProcessId.get(processId).forEach(element => {
                element.parentId = callActivity.id;
            });
        }
    }
    parseProcess(process) {
        const processRef = process.id;
        const pool = this.convertedElements.findPoolByProcessRef(processRef);
        // for pool without name, use the process name instead
        if (pool && !pool.name) {
            this.convertedElements.registerPool(new ShapeBpmnElement(pool.id, process.name, exports.ShapeBpmnElementKind.POOL), processRef);
        }
        this.buildProcessInnerElements(process, pool === null || pool === void 0 ? void 0 : pool.id);
    }
    buildProcessInnerElements(process, parentId) {
        this.elementsWithoutParentByProcessId.set(process.id, []);
        // flow nodes
        ShapeUtil.flowNodeKinds()
            .filter(kind => kind != exports.ShapeBpmnElementKind.EVENT_BOUNDARY)
            .forEach(kind => this.buildFlowNodeBpmnElements(process[kind], kind, parentId, process.id));
        // process boundary events afterwards as we need its parent activity to be available when building it
        this.buildFlowNodeBpmnElements(process.boundaryEvent, exports.ShapeBpmnElementKind.EVENT_BOUNDARY, parentId, process.id);
        // containers
        this.buildLaneBpmnElements(process[exports.ShapeBpmnElementKind.LANE], parentId, process.id);
        this.buildLaneSetBpmnElements(process.laneSet, parentId, process.id);
        // flows
        this.buildSequenceFlows(process.sequenceFlow);
        this.buildAssociationFlows(process.association);
    }
    buildFlowNodeBpmnElements(bpmnElements, kind, parentId, processId) {
        ensureIsArray(bpmnElements).forEach(bpmnElement => {
            let shapeBpmnElement;
            if (ShapeUtil.isEvent(kind)) {
                shapeBpmnElement = this.buildShapeBpmnEvent(bpmnElement, kind, parentId);
            }
            else if (ShapeUtil.isActivity(kind)) {
                shapeBpmnElement = this.buildShapeBpmnActivity(bpmnElement, kind, parentId);
            }
            else if (kind == exports.ShapeBpmnElementKind.GATEWAY_EVENT_BASED) {
                const eventBasedGatewayBpmnElement = bpmnElement;
                shapeBpmnElement = new ShapeBpmnEventBasedGateway(bpmnElement.id, eventBasedGatewayBpmnElement.name, parentId, eventBasedGatewayBpmnElement.instantiate, exports.ShapeBpmnEventBasedGatewayKind[eventBasedGatewayBpmnElement.eventGatewayType]);
            }
            else if (kind == exports.ShapeBpmnElementKind.GROUP) {
                shapeBpmnElement = buildShapeBpmnGroup(this.convertedElements, this.parsingMessageCollector, bpmnElement, parentId);
            }
            else {
                // @ts-ignore We know that the 'text' & 'name' fields are not on all types, but it's already tested
                const name = kind === exports.ShapeBpmnElementKind.TEXT_ANNOTATION ? bpmnElement.text : bpmnElement.name;
                // @ts-ignore We know that the 'instantiate' field is not on all types, but it's already tested
                shapeBpmnElement = new ShapeBpmnElement(bpmnElement.id, name, kind, parentId, bpmnElement.instantiate);
            }
            // @ts-ignore We know that the 'default' field is not on all types, but it's already tested
            const defaultFlow = bpmnElement.default;
            if (ShapeUtil.isWithDefaultSequenceFlow(kind) && defaultFlow) {
                this.defaultSequenceFlowIds.push(defaultFlow);
            }
            if (shapeBpmnElement) {
                this.convertedElements.registerFlowNode(shapeBpmnElement);
                if (!parentId) {
                    this.elementsWithoutParentByProcessId.get(processId).push(shapeBpmnElement);
                }
            }
        });
    }
    buildShapeBpmnActivity(bpmnElement, kind, parentId) {
        const markers = buildMarkers(bpmnElement);
        if (ShapeUtil.isSubProcess(kind)) {
            return this.buildShapeBpmnSubProcess(bpmnElement, parentId, markers);
        }
        if (!ShapeUtil.isCallActivity(kind)) {
            // @ts-ignore
            return new ShapeBpmnActivity(bpmnElement.id, bpmnElement.name, kind, parentId, bpmnElement.instantiate, markers);
        }
        return this.buildShapeBpmnCallActivity(bpmnElement, parentId, markers);
    }
    buildShapeBpmnCallActivity(bpmnElement, parentId, markers) {
        const globalTaskKind = this.convertedElements.findGlobalTask(bpmnElement.calledElement);
        if (!globalTaskKind) {
            const shapeBpmnCallActivity = new ShapeBpmnCallActivity(bpmnElement.id, bpmnElement.name, exports.ShapeBpmnCallActivityKind.CALLING_PROCESS, parentId, markers);
            this.callActivitiesCallingProcess.set(bpmnElement.calledElement, shapeBpmnCallActivity);
            return shapeBpmnCallActivity;
        }
        return new ShapeBpmnCallActivity(bpmnElement.id, bpmnElement.name, exports.ShapeBpmnCallActivityKind.CALLING_GLOBAL_TASK, parentId, markers, globalTaskKind);
    }
    buildShapeBpmnEvent(bpmnElement, elementKind, parentId) {
        const eventDefinitions = this.getEventDefinitions(bpmnElement);
        const numberOfEventDefinitions = eventDefinitions.map(eventDefinition => eventDefinition.counter).reduce((counter, it) => counter + it, 0);
        // do we have a None Event?
        if (numberOfEventDefinitions == 0 && ShapeUtil.canHaveNoneEvent(elementKind)) {
            return new ShapeBpmnEvent(bpmnElement.id, bpmnElement.name, elementKind, exports.ShapeBpmnEventDefinitionKind.NONE, parentId);
        }
        if (numberOfEventDefinitions == 1) {
            const eventDefinitionKind = eventDefinitions[0].kind;
            if (ShapeUtil.isBoundaryEvent(elementKind)) {
                return this.buildShapeBpmnBoundaryEvent(bpmnElement, eventDefinitionKind);
            }
            if (ShapeUtil.isStartEvent(elementKind)) {
                return new ShapeBpmnStartEvent(bpmnElement.id, bpmnElement.name, eventDefinitionKind, parentId, bpmnElement.isInterrupting);
            }
            return new ShapeBpmnEvent(bpmnElement.id, bpmnElement.name, elementKind, eventDefinitionKind, parentId);
        }
    }
    buildShapeBpmnBoundaryEvent(bpmnElement, eventDefinitionKind) {
        const parent = this.convertedElements.findFlowNode(bpmnElement.attachedToRef);
        if (ShapeUtil.isActivity(parent === null || parent === void 0 ? void 0 : parent.kind)) {
            return new ShapeBpmnBoundaryEvent(bpmnElement.id, bpmnElement.name, eventDefinitionKind, bpmnElement.attachedToRef, bpmnElement.cancelActivity);
        }
        else {
            this.parsingMessageCollector.warning(new BoundaryEventNotAttachedToActivityWarning(bpmnElement.id, bpmnElement.attachedToRef, parent === null || parent === void 0 ? void 0 : parent.kind));
        }
    }
    /**
     * Get the list of eventDefinitions hold by the Event bpmElement
     *
     * @param bpmnElement The BPMN element from the XML data which represents a BPMN Event
     */
    getEventDefinitions(bpmnElement) {
        const eventDefinitions = new Map();
        eventDefinitionKinds.forEach(eventDefinitionKind => {
            // sometimes eventDefinition is simple and therefore it is parsed as empty string "", in that case eventDefinition will be converted to an empty object
            const eventDefinition = bpmnElement[eventDefinitionKind + 'EventDefinition'];
            const counter = ensureIsArray(eventDefinition, true).length;
            eventDefinitions.set(eventDefinitionKind, counter);
        });
        ensureIsArray(bpmnElement.eventDefinitionRef).forEach(eventDefinitionRef => {
            const kind = this.convertedElements.findEventDefinitionOfDefinition(eventDefinitionRef);
            eventDefinitions.set(kind, eventDefinitions.get(kind) + 1);
        });
        return Array.from(eventDefinitions.keys())
            .map(kind => ({ kind, counter: eventDefinitions.get(kind) }))
            .filter(eventDefinition => eventDefinition.counter > 0);
    }
    buildShapeBpmnSubProcess(bpmnElement, parentId, markers) {
        const subProcessKind = !bpmnElement.triggeredByEvent ? exports.ShapeBpmnSubProcessKind.EMBEDDED : exports.ShapeBpmnSubProcessKind.EVENT;
        const convertedSubProcess = new ShapeBpmnSubProcess(bpmnElement.id, bpmnElement.name, subProcessKind, parentId, markers);
        this.buildProcessInnerElements(bpmnElement, bpmnElement.id);
        return convertedSubProcess;
    }
    buildLaneSetBpmnElements(laneSets, parentId, processId) {
        ensureIsArray(laneSets).forEach(laneSet => this.buildLaneBpmnElements(laneSet.lane, parentId, processId));
    }
    buildLaneBpmnElements(lanes, parentId, processId) {
        ensureIsArray(lanes).forEach(lane => {
            var _a;
            const shapeBpmnElement = new ShapeBpmnElement(lane.id, lane.name, exports.ShapeBpmnElementKind.LANE, parentId);
            this.convertedElements.registerLane(shapeBpmnElement);
            if (!parentId) {
                this.elementsWithoutParentByProcessId.get(processId).push(shapeBpmnElement);
            }
            this.assignParentOfLaneFlowNodes(lane);
            if ((_a = lane.childLaneSet) === null || _a === void 0 ? void 0 : _a.lane) {
                this.buildLaneBpmnElements(lane.childLaneSet.lane, lane.id, processId);
            }
        });
    }
    assignParentOfLaneFlowNodes(lane) {
        ensureIsArray(lane.flowNodeRef).forEach(flowNodeRef => {
            const shapeBpmnElement = this.convertedElements.findFlowNode(flowNodeRef);
            const laneId = lane.id;
            if (shapeBpmnElement) {
                if (!ShapeUtil.isBoundaryEvent(shapeBpmnElement.kind)) {
                    shapeBpmnElement.parentId = laneId;
                }
            }
            else {
                this.parsingMessageCollector.warning(new LaneUnknownFlowNodeRefWarning(laneId, flowNodeRef));
            }
        });
    }
    buildSequenceFlows(bpmnElements) {
        ensureIsArray(bpmnElements).forEach(sequenceFlow => {
            const kind = this.getSequenceFlowKind(sequenceFlow);
            this.convertedElements.registerSequenceFlow(new SequenceFlow(sequenceFlow.id, sequenceFlow.name, sequenceFlow.sourceRef, sequenceFlow.targetRef, kind));
        });
    }
    buildAssociationFlows(bpmnElements) {
        ensureIsArray(bpmnElements).forEach(association => {
            const direction = association.associationDirection;
            this.convertedElements.registerAssociationFlow(new AssociationFlow(association.id, undefined, association.sourceRef, association.targetRef, direction));
        });
    }
    getSequenceFlowKind(sequenceFlow) {
        if (this.defaultSequenceFlowIds.includes(sequenceFlow.id)) {
            return exports.SequenceFlowKind.DEFAULT;
        }
        else {
            const sourceShapeBpmnElement = this.convertedElements.findFlowNode(sequenceFlow.sourceRef);
            if (sourceShapeBpmnElement && ShapeUtil.isWithDefaultSequenceFlow(sourceShapeBpmnElement.kind) && sequenceFlow.conditionExpression) {
                if (ShapeUtil.isActivity(sourceShapeBpmnElement.kind)) {
                    return exports.SequenceFlowKind.CONDITIONAL_FROM_ACTIVITY;
                }
                else {
                    return exports.SequenceFlowKind.CONDITIONAL_FROM_GATEWAY;
                }
            }
        }
        return exports.SequenceFlowKind.NORMAL;
    }
}
const buildMarkers = (bpmnElement) => {
    const markers = [];
    // @ts-ignore We know that the standardLoopCharacteristics field is not on all types, but it's already tested
    const standardLoopCharacteristics = bpmnElement.standardLoopCharacteristics;
    // @ts-ignore We know that the multiInstanceLoopCharacteristics field is not on all types, but it's already tested
    const multiInstanceLoopCharacteristics = ensureIsArray(bpmnElement.multiInstanceLoopCharacteristics, true)[0];
    if (standardLoopCharacteristics || standardLoopCharacteristics === '') {
        markers.push(exports.ShapeBpmnMarkerKind.LOOP);
    }
    else if (multiInstanceLoopCharacteristics && multiInstanceLoopCharacteristics.isSequential) {
        markers.push(exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_SEQUENTIAL);
    }
    else if ((multiInstanceLoopCharacteristics && !multiInstanceLoopCharacteristics.isSequential) || multiInstanceLoopCharacteristics === '') {
        markers.push(exports.ShapeBpmnMarkerKind.MULTI_INSTANCE_PARALLEL);
    }
    return markers;
};

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class Bounds {
    constructor(x, y, width, height) {
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class Edge {
    constructor(id, bpmnElement, waypoints, label, messageVisibleKind = exports.MessageVisibleKind.NONE) {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: id
        });
        Object.defineProperty(this, "bpmnElement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnElement
        });
        Object.defineProperty(this, "waypoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: waypoints
        });
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: label
        });
        Object.defineProperty(this, "messageVisibleKind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageVisibleKind
        });
    }
}
/**
 * @internal
 */
class Waypoint {
    constructor(x, y) {
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class Label {
    constructor(font, bounds) {
        Object.defineProperty(this, "font", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: font
        });
        Object.defineProperty(this, "bounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bounds
        });
    }
}
/**
 * @internal
 */
class Font {
    constructor(name, size, isBold, isItalic, isUnderline, isStrikeThrough) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: size
        });
        Object.defineProperty(this, "isBold", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isBold
        });
        Object.defineProperty(this, "isItalic", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isItalic
        });
        Object.defineProperty(this, "isUnderline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isUnderline
        });
        Object.defineProperty(this, "isStrikeThrough", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: isStrikeThrough
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class DiagramConverter {
    constructor(convertedElements, parsingMessageCollector) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
        Object.defineProperty(this, "parsingMessageCollector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: parsingMessageCollector
        });
        Object.defineProperty(this, "convertedFonts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    deserialize(bpmnDiagrams) {
        const flowNodes = [];
        const lanes = [];
        const pools = [];
        const edges = [];
        const bpmnDiagram = ensureIsArray(bpmnDiagrams)[0];
        if (bpmnDiagram) {
            // Need to be done before deserialization of Shape and Edge, to link the converted fonts to them
            this.deserializeFonts(bpmnDiagram.BPMNLabelStyle);
            const plane = bpmnDiagram.BPMNPlane;
            const convertedEdges = this.deserializeEdges(plane.BPMNEdge);
            const convertedShapes = this.deserializeShapes(plane.BPMNShape);
            flowNodes.push(...convertedShapes.flowNodes);
            lanes.push(...convertedShapes.lanes);
            pools.push(...convertedShapes.pools);
            edges.push(...convertedEdges);
        }
        return { flowNodes, lanes, pools, edges };
    }
    deserializeFonts(bpmnLabelStyle) {
        this.convertedFonts = new Map();
        ensureIsArray(bpmnLabelStyle).forEach(labelStyle => ensureIsArray(labelStyle.Font).forEach(font => this.convertedFonts.set(labelStyle.id, new Font(font.name, font.size, font.isBold, font.isItalic, font.isUnderline, font.isStrikeThrough))));
    }
    deserializeShapes(shapes) {
        const convertedShapes = { flowNodes: [], lanes: [], pools: [] };
        ensureIsArray(shapes).forEach(shape => {
            // flow nodes
            if (this.deserializeShapeAndStoreIfFound(shape, convertedShapes.flowNodes, (bpmnElementId) => this.convertedElements.findFlowNode(bpmnElementId))) {
                return;
            }
            // lane
            if (this.deserializeShapeAndStoreIfFound(shape, convertedShapes.lanes, (bpmnElementId) => this.convertedElements.findLane(bpmnElementId))) {
                return;
            }
            // pool
            if (this.deserializeShapeAndStoreIfFound(shape, convertedShapes.pools, (bpmnElementId) => this.convertedElements.findPoolById(bpmnElementId))) {
                return;
            }
            // not found
            this.parsingMessageCollector.warning(new ShapeUnknownBpmnElementWarning(shape.bpmnElement));
        });
        return convertedShapes;
    }
    deserializeShapeAndStoreIfFound(shape, storage, findShapeElement) {
        const element = this.deserializeShape(shape, findShapeElement);
        if (element) {
            storage.push(element);
            return true;
        }
        return false;
    }
    deserializeShape(shape, findShapeElement) {
        const bpmnElement = findShapeElement(shape.bpmnElement);
        if (bpmnElement) {
            const bounds = DiagramConverter.deserializeBounds(shape);
            if ((bpmnElement instanceof ShapeBpmnSubProcess ||
                (bpmnElement instanceof ShapeBpmnCallActivity && bpmnElement.callActivityKind === exports.ShapeBpmnCallActivityKind.CALLING_PROCESS)) &&
                !shape.isExpanded) {
                bpmnElement.markers.push(exports.ShapeBpmnMarkerKind.EXPAND);
            }
            let isHorizontal;
            if (ShapeUtil.isPoolOrLane(bpmnElement.kind)) {
                isHorizontal = shape.isHorizontal !== undefined ? shape.isHorizontal : true;
            }
            const label = this.deserializeLabel(shape.BPMNLabel, shape.id);
            return new Shape(shape.id, bpmnElement, bounds, label, isHorizontal);
        }
    }
    static deserializeBounds(boundedElement) {
        const bounds = boundedElement.Bounds;
        if (bounds) {
            return new Bounds(bounds.x, bounds.y, bounds.width, bounds.height);
        }
    }
    deserializeEdges(edges) {
        return ensureIsArray(edges)
            .map(edge => {
            const flow = this.convertedElements.findSequenceFlow(edge.bpmnElement) ||
                this.convertedElements.findMessageFlow(edge.bpmnElement) ||
                this.convertedElements.findAssociationFlow(edge.bpmnElement);
            if (!flow) {
                this.parsingMessageCollector.warning(new EdgeUnknownBpmnElementWarning(edge.bpmnElement));
                return;
            }
            const waypoints = this.deserializeWaypoints(edge.waypoint);
            const label = this.deserializeLabel(edge.BPMNLabel, edge.id);
            const messageVisibleKind = edge.messageVisibleKind ? edge.messageVisibleKind : exports.MessageVisibleKind.NONE;
            return new Edge(edge.id, flow, waypoints, label, messageVisibleKind);
        })
            .filter(Boolean);
    }
    deserializeWaypoints(waypoints) {
        return ensureIsArray(waypoints).map(waypoint => new Waypoint(waypoint.x, waypoint.y));
    }
    deserializeLabel(bpmnLabel, id) {
        if (bpmnLabel && typeof bpmnLabel === 'object') {
            const font = this.findFont(bpmnLabel.labelStyle, id);
            const bounds = DiagramConverter.deserializeBounds(bpmnLabel);
            if (font || bounds) {
                return new Label(font, bounds);
            }
        }
    }
    findFont(labelStyle, id) {
        let font;
        if (labelStyle) {
            font = this.convertedFonts.get(labelStyle);
            if (!font) {
                this.parsingMessageCollector.warning(new LabelStyleMissingFontWarning(id, labelStyle));
            }
        }
        return font;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class EventDefinitionConverter {
    constructor(convertedElements) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
    }
    deserialize(definitions) {
        eventDefinitionKinds.forEach(eventDefinitionKind => {
            // sometimes eventDefinition is simple and therefore it is parsed as empty string "", in that case eventDefinition will be converted to an empty object
            const eventDefinitions = definitions[eventDefinitionKind + 'EventDefinition'];
            ensureIsArray(eventDefinitions, true).forEach(eventDefinition => this.convertedElements.registerEventDefinitionsOfDefinition(eventDefinition.id, eventDefinitionKind));
        });
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class GlobalTaskConverter {
    constructor(convertedElements) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
    }
    deserialize(definitions) {
        this.parseGlobalTasks(definitions.globalTask, exports.ShapeBpmnElementKind.GLOBAL_TASK);
        this.parseGlobalTasks(definitions.globalBusinessRuleTask, exports.ShapeBpmnElementKind.GLOBAL_TASK_BUSINESS_RULE);
        this.parseGlobalTasks(definitions.globalManualTask, exports.ShapeBpmnElementKind.GLOBAL_TASK_MANUAL);
        this.parseGlobalTasks(definitions.globalScriptTask, exports.ShapeBpmnElementKind.GLOBAL_TASK_SCRIPT);
        this.parseGlobalTasks(definitions.globalUserTask, exports.ShapeBpmnElementKind.GLOBAL_TASK_USER);
    }
    parseGlobalTasks(globalTasks, kind) {
        ensureIsArray(globalTasks).forEach(globalTask => this.convertedElements.registerGlobalTask(globalTask.id, kind));
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class CategoryConverter {
    constructor(convertedElements) {
        Object.defineProperty(this, "convertedElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: convertedElements
        });
    }
    deserialize(definitions) {
        ensureIsArray(definitions.category).forEach(category => ensureIsArray(category.categoryValue).forEach(categoryValue => this.convertedElements.registerCategoryValue(categoryValue.id, categoryValue.value)));
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class BpmnJsonParser {
    constructor(categoryConverter, collaborationConverter, eventDefinitionConverter, globalTaskConverter, processConverter, diagramConverter) {
        Object.defineProperty(this, "categoryConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: categoryConverter
        });
        Object.defineProperty(this, "collaborationConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: collaborationConverter
        });
        Object.defineProperty(this, "eventDefinitionConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: eventDefinitionConverter
        });
        Object.defineProperty(this, "globalTaskConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: globalTaskConverter
        });
        Object.defineProperty(this, "processConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: processConverter
        });
        Object.defineProperty(this, "diagramConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: diagramConverter
        });
    }
    parse(json) {
        const definitions = json.definitions;
        this.categoryConverter.deserialize(definitions);
        this.collaborationConverter.deserialize(definitions.collaboration);
        this.eventDefinitionConverter.deserialize(definitions);
        this.globalTaskConverter.deserialize(definitions);
        this.processConverter.deserialize(definitions.process);
        return this.diagramConverter.deserialize(definitions.BPMNDiagram);
    }
}
/**
 * @internal
 */
function newBpmnJsonParser(parsingMessageCollector) {
    const convertedElements = new ConvertedElements();
    return new BpmnJsonParser(new CategoryConverter(convertedElements), new CollaborationConverter(convertedElements, parsingMessageCollector), new EventDefinitionConverter(convertedElements), new GlobalTaskConverter(convertedElements), new ProcessConverter(convertedElements, parsingMessageCollector), new DiagramConverter(convertedElements, parsingMessageCollector));
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class BpmnParser {
    constructor(jsonParser, xmlParser) {
        Object.defineProperty(this, "jsonParser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: jsonParser
        });
        Object.defineProperty(this, "xmlParser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: xmlParser
        });
    }
    parse(bpmnAsXml) {
        const json = this.xmlParser.parse(bpmnAsXml);
        return this.jsonParser.parse(json);
    }
}
/**
 * @internal
 */
function newBpmnParser() {
    return new BpmnParser(newBpmnJsonParser(new ParsingMessageCollector()), new BpmnXmlParser());
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class CssRegistry {
    constructor() {
        Object.defineProperty(this, "classNamesByBPMNId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    /**
     * Clear all classes that were registered.
     */
    clear() {
        this.classNamesByBPMNId.clear();
    }
    /**
     * Get the CSS class names for a specific HTML element
     *
     * @param bpmnElementId the BPMN id of the HTML element from the DOM
     * @return the registered CSS class names
     */
    getClassNames(bpmnElementId) {
        var _a;
        return Array.from((_a = this.classNamesByBPMNId.get(bpmnElementId)) !== null && _a !== void 0 ? _a : []);
    }
    /**
     * Register the CSS class names for a specific HTML element
     *
     * @param bpmnElementId the BPMN id of the HTML element from the DOM
     * @param classNames the CSS class names to register
     * @return true if at least one class name from parameters has been added; false otherwise
     */
    addClassNames(bpmnElementId, classNames) {
        return this.updateClassNames(bpmnElementId, classNames, (currentClassNames, className) => currentClassNames.add(className));
    }
    // return `true` if at least one class has been removed
    removeClassNames(bpmnElementId, classNames) {
        return this.updateClassNames(bpmnElementId, classNames, (currentClassNames, className) => currentClassNames.delete(className));
    }
    // return true if passed classes array has at least one element - as toggle will always trigger changes in that case
    toggleClassNames(bpmnElementId, classNames) {
        this.updateClassNames(bpmnElementId, classNames, (currentClassNames, className) => currentClassNames.has(className) ? currentClassNames.delete(className) : currentClassNames.add(className));
        return classNames && classNames.length > 0;
    }
    updateClassNames(bpmnElementId, classNames, manageClassNames) {
        const currentClassNames = this.getOrInitializeClassNames(bpmnElementId);
        const initialClassNamesNumber = currentClassNames.size;
        ensureIsArray(classNames).forEach(className => manageClassNames(currentClassNames, className));
        return currentClassNames.size != initialClassNamesNumber;
    }
    getOrInitializeClassNames(bpmnElementId) {
        let classNames = this.classNamesByBPMNId.get(bpmnElementId);
        if (classNames == null) {
            classNames = new Set();
            this.classNamesByBPMNId.set(bpmnElementId, classNames);
        }
        return classNames;
    }
}

class OverlayConverter {
    constructor() {
        Object.defineProperty(this, "overlayPositions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map([
                // Edge
                ['start', { horizontalAlign: 'left', verticalAlign: 'top' }],
                ['middle', { horizontalAlign: 'center', verticalAlign: 'top' }],
                ['end', { horizontalAlign: 'right', verticalAlign: 'top' }],
                // Shape
                ['top-left', { horizontalAlign: 'left', verticalAlign: 'top' }],
                ['top-right', { horizontalAlign: 'right', verticalAlign: 'top' }],
                ['top-center', { horizontalAlign: 'center', verticalAlign: 'top' }],
                ['bottom-left', { horizontalAlign: 'left', verticalAlign: 'bottom' }],
                ['bottom-right', { horizontalAlign: 'right', verticalAlign: 'bottom' }],
                ['bottom-center', { horizontalAlign: 'center', verticalAlign: 'bottom' }],
                ['middle-left', { horizontalAlign: 'left', verticalAlign: 'middle' }],
                ['middle-right', { horizontalAlign: 'right', verticalAlign: 'middle' }],
            ])
        });
    }
    convert(overlay) {
        const position = this.convertPosition(overlay);
        const style = OverlayConverter.convertStyle(overlay);
        return { position, style };
    }
    convertPosition(overlay) {
        return this.overlayPositions.get(overlay.position);
    }
    static convertStyle(overlay) {
        // recompute the style at each call to ensure we consider default changes that could occur after lib initialization
        const defaultStyle = {
            fill: { color: exports.StyleDefault.DEFAULT_OVERLAY_FILL_COLOR.valueOf(), opacity: exports.StyleDefault.DEFAULT_OVERLAY_FILL_OPACITY.valueOf() },
            stroke: { color: exports.StyleDefault.DEFAULT_OVERLAY_STROKE_COLOR.valueOf(), width: exports.StyleDefault.DEFAULT_OVERLAY_STROKE_WIDTH.valueOf() },
            font: { color: exports.StyleDefault.DEFAULT_OVERLAY_FONT_COLOR.valueOf(), size: exports.StyleDefault.DEFAULT_OVERLAY_FONT_SIZE.valueOf() },
        };
        const style = overlay.style;
        const convertedStyle = Object.assign({}, defaultStyle);
        if (!style) {
            return convertedStyle;
        }
        this.convertFill(convertedStyle, style.fill);
        this.convertStroke(convertedStyle, style.stroke);
        this.convertFont(convertedStyle, style.font);
        return convertedStyle;
    }
    static convertFill(convertedStyle, apiFill) {
        var _a, _b;
        if (apiFill) {
            convertedStyle.fill.color = (_a = apiFill.color) !== null && _a !== void 0 ? _a : convertedStyle.fill.color;
            convertedStyle.fill.opacity = (_b = apiFill.opacity) !== null && _b !== void 0 ? _b : convertedStyle.fill.opacity;
        }
    }
    static convertStroke(convertedStyle, apiStroke) {
        var _a, _b;
        if (apiStroke) {
            convertedStyle.stroke.color = (_a = apiStroke.color) !== null && _a !== void 0 ? _a : convertedStyle.stroke.color;
            convertedStyle.stroke.width = (_b = apiStroke.width) !== null && _b !== void 0 ? _b : convertedStyle.stroke.width;
        }
    }
    static convertFont(convertedStyle, apiFont) {
        var _a, _b;
        if (apiFont) {
            convertedStyle.font.color = (_a = apiFont.color) !== null && _a !== void 0 ? _a : convertedStyle.font.color;
            convertedStyle.font.size = (_b = apiFont.size) !== null && _b !== void 0 ? _b : convertedStyle.font.size;
        }
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
function newGraphCellUpdater(graph) {
    return new GraphCellUpdater(graph, new OverlayConverter());
}
/**
 * @internal
 */
class GraphCellUpdater {
    constructor(graph, overlayConverter) {
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graph
        });
        Object.defineProperty(this, "overlayConverter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: overlayConverter
        });
    }
    updateAndRefreshCssClassesOfCell(bpmnElementId, cssClasses) {
        this.updateAndRefreshCssClassesOfElement(bpmnElementId, cssClasses);
        // special case: message flow icon is stored in a dedicated mxCell, so it must be kept in sync
        this.updateAndRefreshCssClassesOfElement(messageFowIconId(bpmnElementId), cssClasses);
    }
    updateAndRefreshCssClassesOfElement(elementId, cssClasses) {
        var _a;
        const mxCell = this.graph.getModel().getCell(elementId);
        if (!mxCell) {
            return;
        }
        const view = this.graph.getView();
        const state = view.getState(mxCell);
        state.style[BpmnStyleIdentifier.EXTRA_CSS_CLASSES] = cssClasses;
        state.shape.redraw();
        // Ensure that label classes are also updated. When there is no label, state.text is null
        (_a = state.text) === null || _a === void 0 ? void 0 : _a.redraw();
    }
    addOverlays(bpmnElementId, overlays) {
        const mxCell = this.graph.getModel().getCell(bpmnElementId);
        if (!mxCell) {
            return;
        }
        ensureIsArray(overlays).forEach(overlay => {
            const bpmnOverlay = new MxGraphCustomOverlay(overlay.label, this.overlayConverter.convert(overlay));
            this.graph.addCellOverlay(mxCell, bpmnOverlay);
        });
    }
    removeAllOverlays(bpmnElementId) {
        const mxCell = this.graph.getModel().getCell(bpmnElementId);
        if (!mxCell) {
            return;
        }
        this.graph.removeCellOverlays(mxCell);
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Once mxGraph is initialized at BpmnVisualization construction, prior loading a BPMN diagram, the DOM looks like:
 * ```html
 * <div id="bpmn-container" style="touch-action: none;">
 *   <svg style="left: 0px; top: 0px; width: 100%; height: 100%; display: block; min-width: 1px; min-height: 1px;">
 *     <g>
 *       <g></g>
 *       <g></g>
 *       <g></g>
 *       <g></g>
 *     </g>
 *   </svg>
 * </div>
 * ```
 * mxGraph generates the following SVG groups (see https://github.com/jgraph/mxgraph/blob/v4.2.2/javascript/src/js/view/mxGraphView.js#L2862)
 *   - 1st: for background image
 *   - 2nd: elements of the graph (shapes and edges)
 *   - 3rd: overlays
 *   - 4th: decorators
 *
 * After loading, the DOM looks like:
 * ```html
 * <div id="bpmn-container" style="touch-action: none;">
 *   <svg style="left: 0px; top: 0px; width: 100%; height: 100%; display: block; min-width: 900px; min-height: 181px;">
 *     <g>
 *       <g></g>
 *       <g>
 *         <g style="" class="bpmn-pool" data-bpmn-id="Participant_1">....</g>
 *       </g>
 *       <g>
 *         <g style="" class="overlay-badge" data-bpmn-id="Participant_1">...</g>
 *       </g>
 *       <g></g>
 *     </g>
 *   </svg>
 * </div>
 * ```
 * In the 2nd 'g' node, children 'g' nodes with the 'data-bpmn-id' attribute (extra attribute generated by the lib) are only available when the rendering is done
 * @internal
 */
class BpmnQuerySelectors {
    constructor(containerId) {
        Object.defineProperty(this, "containerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: containerId
        });
    }
    element(bpmnElementId) {
        return `#${this.containerId} > svg > g > g > g[data-bpmn-id="${bpmnElementId}"]`;
    }
    elementsOfKind(bpmnKindCssClassname) {
        return `#${this.containerId} > svg > g > g > g.${bpmnKindCssClassname}:not(.bpmn-label)`;
    }
}

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
function newBpmnElementsRegistry(bpmnModelRegistry, graph) {
    var _a;
    return new BpmnElementsRegistry(bpmnModelRegistry, new HtmlElementRegistry(new BpmnQuerySelectors((_a = graph.container) === null || _a === void 0 ? void 0 : _a.id)), new CssRegistry(), newGraphCellUpdater(graph));
}
/**
 * `BpmnElementRegistry` is a public API that permits to find the BpmnElements present in the diagram.
 * How to access it:
 *
 * ```javascript
 * // 1. Initialize the BpmnVisualization.
 * const bpmnVisualization = new BpmnVisualization({ container: 'bpmn-container' });
 * // 2. Get diagram and load it.
 * const bpmn = 'BPMN diagram string - whether coming from bpmn.xml file or some API call';
 * bpmnVisualization.load(bpmn);
 * // 3. Access registry directly from bpmnVisualization.
 * bpmnVisualization.bpmnElementsRegistry
 * ```
 *
 * **WARN**: subject to change, feedback welcome.
 *
 *  @category Custom Behavior
 *  @experimental
 */
class BpmnElementsRegistry {
    /**
     * @internal
     */
    constructor(bpmnModelRegistry, htmlElementRegistry, cssRegistry, graphCellUpdater) {
        Object.defineProperty(this, "bpmnModelRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bpmnModelRegistry
        });
        Object.defineProperty(this, "htmlElementRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: htmlElementRegistry
        });
        Object.defineProperty(this, "cssRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cssRegistry
        });
        Object.defineProperty(this, "graphCellUpdater", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graphCellUpdater
        });
        this.bpmnModelRegistry.registerOnLoadCallback(this.cssRegistry.clear.bind(this.cssRegistry));
    }
    /**
     * Get all elements by ids. The returned array contains elements in the order of the `bpmnElementIds` parameter.
     *
     * Not found elements are not returned as undefined in the array, so the returned array contains at most as much elements as the `bpmnElementIds` parameter.
     *
     * ```javascript
     * ...
     * // Find all elements by specified id or ids
     * const bpmnElements1 = bpmnVisualization.bpmnElementsRegistry.getElementsByIds('userTask_1');
     * const bpmnElements2 = bpmnVisualization.bpmnElementsRegistry.getElementsByIds(['startEvent_3', 'userTask_2']);
     * // now you can do whatever you want with the elements
     * ...
     * ```
     *
     * **WARNING**: this method is not designed to accept a large amount of ids. It does DOM lookup to retrieve the HTML elements relative to the BPMN elements.
     * Attempts to retrieve too many elements, especially on large BPMN diagram, may lead to performance issues.
     */
    getElementsByIds(bpmnElementIds) {
        return ensureIsArray(bpmnElementIds)
            .map(id => this.bpmnModelRegistry.getBpmnSemantic(id))
            .filter(Boolean)
            .map(bpmnSemantic => ({ bpmnSemantic: bpmnSemantic, htmlElement: this.htmlElementRegistry.getBpmnHtmlElement(bpmnSemantic.id) }));
    }
    /**
     * Get all elements by kinds.
     *
     * ```javascript
     * ...
     * // Find all elements by desired type or types
     * const bpmnTaskElements = bpmnVisualization.bpmnElementsRegistry.getElementsByKinds(ShapeBpmnElementKind.TASK);
     * const bpmnEndEventAndPoolElements = bpmnVisualization.bpmnElementsRegistry.getElementsByKinds([ShapeBpmnElementKind.EVENT_END, ShapeBpmnElementKind.POOL]);
     * // now you can do whatever you want with the elements
     * ...
     * ```
     *
     * **WARNING**: this method is not designed to accept a large amount of types. It does DOM lookup to retrieve the HTML elements relative to the BPMN elements.
     * Attempts to retrieve too many elements, especially on large BPMN diagrams, may lead to performance issues.
     */
    getElementsByKinds(bpmnKinds) {
        return ensureIsArray(bpmnKinds)
            .map(kind => this.htmlElementRegistry.getBpmnHtmlElements(kind).map(htmlElement => ({
            htmlElement: htmlElement,
            bpmnSemantic: this.bpmnModelRegistry.getBpmnSemantic(htmlElement.getAttribute('data-bpmn-id')),
        })))
            .reduce((accumulator, bpmnElements) => {
            accumulator.push(...bpmnElements);
            return accumulator;
        }, []);
    }
    /**
     * Add one/several CSS class(es) to one/several BPMN element(s).
     *
     * Notice that if you pass ids that are not related to existing BPMN elements, their reference will be kept within the registry but nothing happens on the rendering side.
     *
     * @example
     * ```javascript
     * // Add 'success-path' to BPMN elements with id: flow_1 and flow_5
     * bpmnVisualization.bpmnElementsRegistry.addCssClasses(['flow_1', 'flow_5'], 'success-path');
     *
     * // Add 'suspicious-path' and 'additional-info' to BPMN element with id: task_3
     * bpmnVisualization.bpmnElementsRegistry.addCssClasses('task_3', ['suspicious-path', 'additional-info']);
     * ```
     *
     * **Notes**:
     *
     * - This method is intended to set CSS classes to specific elements, for instance to hide or highlight them. During BPMN diagram rendering, `bpmn-visualization` set specific CSS classes to all elements regarding their types.
     * So, if you want to style all elements of a given type, use these default classes instead of adding new ones. The classes allow identifying elements of the same 'family' and of the same specific type.
     * - For instance, a BPMN Service Task is an `Activity` and a `Task`, so it has the `bpmn-type-activity` and the `bpmn-type-task` classes. It shares these classes with all types of `Tasks`.
     * It also has the specific `bpmn-service-task` to differentiate it from a BPMN User Task that has a `bpmn-user-task`.
     * - In addition, labels also have the `bpmn-label` classes.
     *
     * Check the examples for more details.
     *
     * @param bpmnElementIds The BPMN id of the element(s) where to add the CSS classes
     * @param classNames The name of the class(es) to add to the BPMN element(s)
     */
    addCssClasses(bpmnElementIds, classNames) {
        this.updateCssClasses(bpmnElementIds, classNames, this.cssRegistry.addClassNames.bind(this.cssRegistry));
    }
    /**
     * Remove one/several CSS class(es) previously added with the `addCssClasses` or the `toggleCssClasses` methods from one/several BPMN element(s).
     *
     * @example
     * ```javascript
     * // Remove 'highlight' from BPMN elements with id: activity_1 and activity_2
     * bpmnVisualization.bpmnElementsRegistry.removeCssClasses(['activity_1', 'activity_2'], 'highlight');
     *
     * // Remove 'running' and 'additional-info' from BPMN element with id: task_3
     * bpmnVisualization.bpmnElementsRegistry.removeCssClasses('task_3', ['running', 'additional-info']);
     * ```
     *
     * @param bpmnElementIds The BPMN id of the element(s) where to remove the CSS classes
     * @param classNames The name of the class(es) to remove from the BPMN element(s)
     */
    removeCssClasses(bpmnElementIds, classNames) {
        this.updateCssClasses(bpmnElementIds, classNames, this.cssRegistry.removeClassNames.bind(this.cssRegistry));
    }
    /**
     * Toggle one/several CSS class(es) for one/several BPMN element(s).
     * Notice that if you pass ids that are not related to existing BPMN elements, their reference will be kept within the registry but nothing happens on the rendering side.
     *
     * @example
     * ```javascript
     * // Toggle 'highlight' for BPMN elements with id: activity_1 and activity_2
     * bpmnVisualization.bpmnElementsRegistry.toggleCssClasses(['activity_1', 'activity_2'], 'highlight');
     *
     * // Toggle 'running' and 'additional-info' for BPMN element with id: task_3
     * bpmnVisualization.bpmnElementsRegistry.toggleCssClasses('task_3', ['running', 'additional-info']);
     * ```
     *
     * @param bpmnElementIds The BPMN id of the element(s) where to remove the CSS classes
     * @param classNames The name of the class(es) to remove from the BPMN element(s)
     */
    toggleCssClasses(bpmnElementIds, classNames) {
        this.updateCssClasses(bpmnElementIds, classNames, this.cssRegistry.toggleClassNames.bind(this.cssRegistry));
    }
    updateCssClasses(bpmnElementIds, classNames, updateClassNames) {
        const arrayClassNames = ensureIsArray(classNames);
        ensureIsArray(bpmnElementIds).forEach(bpmnElementId => this.updateCellIfChanged(updateClassNames(bpmnElementId, arrayClassNames), bpmnElementId));
    }
    updateCellIfChanged(updateCell, bpmnElementId) {
        if (updateCell) {
            const allClassNames = this.cssRegistry.getClassNames(bpmnElementId);
            this.graphCellUpdater.updateAndRefreshCssClassesOfCell(bpmnElementId, allClassNames);
        }
    }
    /**
     * Add one/several overlays to a BPMN element.
     *
     * Notice that if you pass an id that is not related to an existing BPMN element, nothing happens on the rendering side.
     *
     * @example
     * ```javascript
     * // Add an overlay to BPMN elements with id 'task_1'
     * bpmnVisualization.bpmnElementsRegistry.addOverlays('task_1', {
     *    position: 'top-left',
     *    label: '40',
     *    style: {
     *      font: { color: 'Chartreuse', size: 8 },
     *      fill: { color: 'Pink', opacity: 50 },
     *      stroke: { color: 'DarkSeaGreen', width: 2 }
     *    }
     * });
     *
     * // Add several overlays to BPMN element with id 'task_3'
     * bpmnVisualization.bpmnElementsRegistry.addOverlays('task_3', [
     *    {
     *      position: 'bottom-right',
     *      label: '110',
     *      style: {
     *        font: { color: '#663399', size: 8 },
     *        fill: { color: '#FFDAB9', opacity: 50 },
     *        stroke: { color: 'DarkSeaGreen', width: 2 }
     *      }
     *    },
     *    {
     *      position: 'top-left',
     *      label: '40',
     *      style: {
     *        font: { color: 'MidnightBlue', size: 30 },
     *        fill: { color: 'Aquamarine', opacity: 70 },
     *        stroke: { color: '#4B0082', width: 1 }
     *      }
     *    }
     * ]);
     * ```
     *
     * @param bpmnElementId The BPMN id of the element where to add the overlays
     * @param overlays The overlays to add to the BPMN element
     */
    addOverlays(bpmnElementId, overlays) {
        this.graphCellUpdater.addOverlays(bpmnElementId, overlays);
    }
    /**
     * Remove all overlays of a BPMN element.
     *
     * <b>WARNING</b>: could be renamed when adding support for removal of one or several specific overlays.
     *
     * @example
     * ```javascript
     * //  all overlays of the BPMN element with id: activity_1
     * bpmnVisualization.bpmnElementsRegistry.removeAllOverlays('activity_1');
     * ```
     *
     * @param bpmnElementId The BPMN id of the element where to remove the overlays
     */
    removeAllOverlays(bpmnElementId) {
        this.graphCellUpdater.removeAllOverlays(bpmnElementId);
    }
}
class HtmlElementRegistry {
    constructor(querySelectors) {
        Object.defineProperty(this, "querySelectors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: querySelectors
        });
    }
    /**
     * Returns `null` if no element is found.
     * @param bpmnElementId the id of the BPMN element represented by the searched Html Element.
     */
    getBpmnHtmlElement(bpmnElementId) {
        return document.querySelector(this.querySelectors.element(bpmnElementId));
    }
    getBpmnHtmlElements(bpmnElementKind) {
        const selectors = this.querySelectors.elementsOfKind(computeBpmnBaseClassName(bpmnElementKind));
        return [...document.querySelectorAll(selectors)];
    }
}

/**
 * Copyright 2022 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class ModelFiltering {
    filter(bpmnModel, modelFilter) {
        const poolIdsFilter = [];
        const poolNamesFilter = [];
        ensureIsArray(modelFilter === null || modelFilter === void 0 ? void 0 : modelFilter.pools)
            .filter(p => p && Object.keys(p).length)
            .forEach(filter => (filter.id ? poolIdsFilter.push(filter.id) : filter.name && poolNamesFilter.push(filter.name)));
        if (poolIdsFilter.length == 0 && poolNamesFilter.length == 0) {
            return bpmnModel;
        }
        const { filteredPools, filteredPoolIds } = filterPools(bpmnModel, poolIdsFilter, poolNamesFilter);
        const filteredPoolAndBlackPoolIds = [...poolIdsFilter, ...filteredPoolIds];
        const { filteredLanes, filteredLaneIds, filteredFlowNodes, filteredFlowNodeIds } = filterLanesAndFlowNodes(bpmnModel.lanes, bpmnModel.flowNodes, filteredPoolAndBlackPoolIds);
        const filteredEdges = filterEdges(bpmnModel.edges, [...filteredPoolAndBlackPoolIds, ...filteredLaneIds, ...filteredFlowNodeIds]);
        // For the NOT displayed Pool, there is no Shape for it, but we need to filter the flow nodes, the lanes and the edges which are in the NOT displayed Pool
        // If there is no shape associated to a Pool, no flow nodes, no lanes and no edges, there is no ShapeBPMNElement associated to the pool id to filter.
        // So we need to throw an error.
        if (filteredPools.length == 0 && filteredLanes.length == 0 && filteredFlowNodes.length == 0 && filteredEdges.length == 0) {
            let errorMsgSuffix = poolIdsFilter.length > 0 ? ` for ids [${poolIdsFilter}]` : '';
            const msgSeparator = errorMsgSuffix ? ' and' : '';
            errorMsgSuffix += poolNamesFilter.length > 0 ? `${msgSeparator} for names [${poolNamesFilter}]` : '';
            throw new Error('No matching pools' + errorMsgSuffix);
        }
        return { lanes: filteredLanes, flowNodes: filteredFlowNodes, pools: filteredPools, edges: filteredEdges };
    }
}
function filterPools(bpmnModel, poolIdsFilter, poolNamesFilter) {
    const filteredPools = bpmnModel.pools.filter(pool => poolIdsFilter.includes(pool.bpmnElement.id) || poolNamesFilter.includes(pool.bpmnElement.name));
    const filteredPoolIds = filteredPools.map(shape => shape.bpmnElement.id);
    return { filteredPools, filteredPoolIds };
}
function filterLanesAndFlowNodes(lanes, flowNodes, parentIdsToFilter) {
    const { filteredLanes, filteredLaneIds } = filterLanes(lanes, parentIdsToFilter);
    const { filteredLanes: filteredSubLanes, filteredLaneIds: filteredSubLanesIds, filteredFlowNodes, filteredFlowNodeIds, } = filterFlowNodes(flowNodes, [...parentIdsToFilter, ...filteredLaneIds], lanes);
    filteredLanes.push(...filteredSubLanes);
    filteredLaneIds.push(...filteredSubLanesIds);
    return { filteredLanes, filteredLaneIds, filteredFlowNodes, filteredFlowNodeIds };
}
function filterLanes(lanes, parentIdsToFilter) {
    const filteredLanes = lanes.filter(shape => parentIdsToFilter.includes(shape.bpmnElement.parentId));
    const filteredLaneIds = filteredLanes.map(shape => shape.bpmnElement.id);
    if (filteredLanes.length > 0) {
        const { filteredLanes: filteredSubLanes, filteredLaneIds: filteredSubLaneIds } = filterLanes(lanes, filteredLaneIds);
        filteredLanes.push(...filteredSubLanes);
        filteredLaneIds.push(...filteredSubLaneIds);
    }
    return { filteredLanes, filteredLaneIds };
}
function filterFlowNodes(flowNodes, parentIdsToFilter, lanes) {
    const filteredFlowNodes = flowNodes.filter(shape => parentIdsToFilter.includes(shape.bpmnElement.parentId));
    if (filteredFlowNodes.length === 0) {
        return { filteredLanes: [], filteredLaneIds: [], filteredFlowNodes: [], filteredFlowNodeIds: [] };
    }
    // manage children of subprocesses / call activity and boundary events attached to tasks
    const filteredFlowNodeIds = filteredFlowNodes.map(shape => shape.bpmnElement.id);
    const { filteredLanes, filteredLaneIds, filteredFlowNodes: filteredChildFlowNodes, filteredFlowNodeIds: filteredChildFlowNodeIds, } = filterLanesAndFlowNodes(lanes, flowNodes, filteredFlowNodeIds);
    filteredFlowNodes.push(...filteredChildFlowNodes);
    filteredFlowNodeIds.push(...filteredChildFlowNodeIds);
    return { filteredLanes, filteredLaneIds, filteredFlowNodes, filteredFlowNodeIds };
}
function filterEdges(edges, filteredElementIds) {
    return edges.filter(edge => filteredElementIds.includes(edge.bpmnElement.sourceRefId) && filteredElementIds.includes(edge.bpmnElement.targetRefId));
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class BpmnModelRegistry {
    constructor() {
        Object.defineProperty(this, "searchableModel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "onLoadCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    load(bpmnModel, modelFilter) {
        var _a;
        const filteredModel = new ModelFiltering().filter(bpmnModel, modelFilter);
        this.searchableModel = new SearchableModel(filteredModel);
        (_a = this.onLoadCallback) === null || _a === void 0 ? void 0 : _a.call(this);
        return toRenderedModel(filteredModel);
    }
    registerOnLoadCallback(callback) {
        this.onLoadCallback = callback;
    }
    getBpmnSemantic(bpmnElementId) {
        const element = this.searchableModel.elementById(bpmnElementId);
        if (!element) {
            return undefined;
        }
        const bpmnElement = element.bpmnElement;
        const isShape = bpmnElement instanceof ShapeBpmnElement;
        return { id: bpmnElementId, name: bpmnElement.name, isShape: isShape, kind: bpmnElement.kind };
    }
}
function toRenderedModel(bpmnModel) {
    const collapsedSubProcessIds = bpmnModel.flowNodes
        .filter(shape => {
        const bpmnElement = shape.bpmnElement;
        return ShapeUtil.isSubProcess(bpmnElement.kind) && bpmnElement.markers.includes(exports.ShapeBpmnMarkerKind.EXPAND);
    })
        .map(shape => shape.bpmnElement.id);
    const subprocesses = [];
    const boundaryEvents = [];
    const otherFlowNodes = [];
    bpmnModel.flowNodes.forEach(shape => {
        const kind = shape.bpmnElement.kind;
        if (ShapeUtil.isSubProcess(kind)) {
            subprocesses.push(shape);
        }
        else if (ShapeUtil.isBoundaryEvent(kind)) {
            boundaryEvents.push(shape);
        }
        else if (!collapsedSubProcessIds.includes(shape.bpmnElement.parentId)) {
            otherFlowNodes.push(shape);
        }
    });
    return { boundaryEvents: boundaryEvents, edges: bpmnModel.edges, lanes: bpmnModel.lanes, otherFlowNodes: otherFlowNodes, pools: bpmnModel.pools, subprocesses: subprocesses };
}
class SearchableModel {
    constructor(bpmnModel) {
        Object.defineProperty(this, "elements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        []
            .concat(bpmnModel.pools, bpmnModel.lanes, bpmnModel.flowNodes, bpmnModel.edges)
            // use the bpmn element id and not the bpmn shape id
            .forEach(e => this.elements.set(e.bpmnElement.id, e));
    }
    elementById(id) {
        return this.elements.get(id);
    }
}

/**
 * Copyright 2021 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
function htmlElement(element) {
    if (element instanceof HTMLElement) {
        return element;
    }
    return document.getElementById(element);
}

/**
 * Copyright 2022 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Perform BPMN diagram navigation.
 *
 * **WARN**: subject to change, feedback welcome.
 *
 * @category Navigation
 * @experimental
 * @since 0.24.0
 */
class Navigation {
    constructor(graph) {
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: graph
        });
    }
    fit(options) {
        this.graph.customFit(options);
    }
    zoom(type) {
        type == 'in' ? this.graph.zoomIn() : this.graph.zoomOut();
    }
}

/**
 * Copyright 2022 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// WARN: this constant is automatically updated at release time by the 'manage-version-in-files.mjs' script.
// So, if you modify the name of this file or this constant, please update the script accordingly.
const libVersion = '0.27.0';
/**
 * @internal
 */
const version = () => {
    return { lib: libVersion, dependencies: new Map([['mxGraph', mxgraph.mxClient.VERSION]]) };
};

/**
 * Copyright 2020 Bonitasoft S.A.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Let initialize `bpmn-visualization`. It requires at minimum to pass the HTMLElement in the page where the BPMN diagram is rendered.
 * ```javascript
 * const bpmnVisualization = new BpmnVisualization({ container: 'bpmn-container' });
 * ```
 * For more options, see {@link GlobalOptions}
 *
 * @category Initialization & Configuration
 */
class BpmnVisualization {
    constructor(options) {
        /**
         * Direct access to the `mxGraph` instance that powers `bpmn-visualization`.
         * It is for **advanced users**, so please use the lib API first and access to the `mxGraph` instance only when there is no alternative.
         *
         * **WARN**: subject to change, could be removed or made available in another way.
         *
         * @experimental
         */
        Object.defineProperty(this, "graph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Perform BPMN diagram navigation.
         *
         * **WARN**: subject to change, feedback welcome.
         *
         * @experimental
         * @since 0.24.0
         */
        Object.defineProperty(this, "navigation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Interact with BPMN diagram elements rendered in the page.
         *
         * **WARN**: subject to change, feedback welcome.
         *
         * @experimental
         */
        Object.defineProperty(this, "bpmnElementsRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bpmnModelRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // mxgraph configuration
        const configurator = new GraphConfigurator(htmlElement(options === null || options === void 0 ? void 0 : options.container));
        this.graph = configurator.configure(options);
        // other configurations
        this.navigation = new Navigation(this.graph);
        this.bpmnModelRegistry = new BpmnModelRegistry();
        this.bpmnElementsRegistry = newBpmnElementsRegistry(this.bpmnModelRegistry, this.graph);
    }
    /**
     * Load and render the BPMN diagram.
     * @param xml The BPMN content as xml string
     * @param options Let decide how to load the model and render the diagram
     * @throws `Error` when loading fails. This is generally due to a parsing error caused by a malformed BPMN content
     */
    load(xml, options) {
        const bpmnModel = newBpmnParser().parse(xml);
        const renderedModel = this.bpmnModelRegistry.load(bpmnModel, options === null || options === void 0 ? void 0 : options.modelFilter);
        newBpmnRenderer(this.graph).render(renderedModel, options === null || options === void 0 ? void 0 : options.fit);
    }
    getVersion() {
        return version();
    }
}

exports.BpmnCanvas = BpmnCanvas;
exports.BpmnElementsRegistry = BpmnElementsRegistry;
exports.BpmnStyleIdentifier = BpmnStyleIdentifier;
exports.BpmnVisualization = BpmnVisualization;
exports.IconPainter = IconPainter;
exports.IconPainterProvider = IconPainterProvider;
exports.MarkerIdentifier = MarkerIdentifier;
exports.ShapeUtil = ShapeUtil;
exports.StyleConfigurator = StyleConfigurator;
exports.StyleUtils = StyleUtils;
